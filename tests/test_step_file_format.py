#!/usr/bin/env python3
"""
Test Suite for Step File Format Validation

Validates that step files generated by /nw:split have the correct structure,
including proper phase names, required fields, and tdd_cycle configuration.

Test isolation: Each test uses temporary files, no shared mutable state.
"""

import json
import pytest
import sys
from pathlib import Path
from typing import Any, Dict, List

# Add project root to Python path for module import
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

# Import validation functions from scripts/validation/validate_steps.py
from scripts.validation.validate_steps import (  # noqa: E402
    REQUIRED_PHASES,
    validate_step_file,
    validate_phase_execution_log,
)


# Import from single source of truth
from nWave.constants.tdd_phases import REQUIRED_PHASES as CORRECT_PHASE_NAMES, PHASE_COUNT  # noqa: E402

# =============================================================================
# Test Constants - Expected Format
# =============================================================================

# WRONG phase names that should be detected and rejected
WRONG_PHASE_NAMES = [
    "RED (Acceptance)",  # Wrong: uses parentheses and space
    "RED (Unit)",  # Wrong: uses parentheses and space
    "GREEN (Unit)",  # Wrong: uses parentheses and space
    "CHECK (Acceptance)",  # Wrong: uses parentheses and space
    "GREEN (Acceptance)",  # Wrong: uses parentheses and space
    "RED_Accept",  # Wrong: abbreviated
    "Red_Acceptance",  # Wrong: wrong case
    "REFACTOR",  # Wrong: missing level
    "POST-REFACTOR-REVIEW",  # Wrong: uses hyphens
]


# =============================================================================
# Fixtures - Test Data Generation
# =============================================================================


def create_valid_phase_execution_log() -> List[Dict[str, Any]]:
    """Create a valid phase_execution_log with all 8 phases (schema v2.0)."""
    return [
        {
            "phase_name": phase_name,
            "phase_index": i,
            "status": "NOT_EXECUTED",
            "started_at": None,
            "ended_at": None,
            "duration_minutes": None,
            "artifacts": [],
            "notes": "",
            "validation_result": None,
        }
        for i, phase_name in enumerate(CORRECT_PHASE_NAMES)
    ]


def create_valid_step_file() -> Dict[str, Any]:
    """Create a complete valid step file structure."""
    return {
        "task_id": "01-01",
        "project_id": "test-project",
        "execution_agent": "@software-crafter",
        "self_contained_context": {
            "business_context": "Test business context",
            "technical_context": "Test technical context",
        },
        "task_specification": {
            "description": "Test task description",
            "acceptance_criteria": ["AC1", "AC2"],
        },
        "dependencies": {"required_steps": [], "blockers": []},
        "state": {
            "status": "pending",
            "current_phase": None,
            "last_updated": "2025-01-15T10:00:00Z",
        },
        "tdd_cycle": {
            "acceptance_test": {
                "scenario": "Test scenario",
                "gherkin": "Given...\nWhen...\nThen...",
            },
            "phase_execution_log": create_valid_phase_execution_log(),
        },
        "quality_gates": {
            "pre_commit": {"all_tests_pass": False, "coverage_threshold": 80},
            "post_commit": {"ci_pipeline_pass": False},
        },
        "phase_validation_rules": {
            "red_acceptance_must_fail": True,
            "green_acceptance_must_pass": True,
        },
    }


@pytest.fixture
def valid_step_file(tmp_path) -> Path:
    """Create a valid step file for testing."""
    step_file = tmp_path / "valid-step.json"
    step_file.write_text(json.dumps(create_valid_step_file(), indent=2))
    return step_file


@pytest.fixture
def step_with_wrong_phase_names(tmp_path) -> Path:
    """Create step file with WRONG phase names (old format)."""
    data = create_valid_step_file()
    # Replace phase names with wrong format - use 8-phase structure with some wrong names
    wrong_phases = [
        {"phase_name": "PREPARE", "phase_index": 0, "status": "NOT_EXECUTED"},
        {
            "phase_name": "RED (Acceptance)",
            "phase_index": 1,
            "status": "NOT_EXECUTED",
        },  # WRONG
        {
            "phase_name": "RED (Unit)",
            "phase_index": 2,
            "status": "NOT_EXECUTED",
        },  # WRONG
        {
            "phase_name": "GREEN (Unit)",
            "phase_index": 3,
            "status": "NOT_EXECUTED",
        },  # WRONG - should be GREEN
        {"phase_name": "REVIEW", "phase_index": 4, "status": "NOT_EXECUTED"},
        {"phase_name": "REFACTOR_CONTINUOUS", "phase_index": 5, "status": "NOT_EXECUTED"},
        {"phase_name": "REFACTOR_L4", "phase_index": 6, "status": "NOT_EXECUTED"},
        {"phase_name": "COMMIT", "phase_index": 7, "status": "NOT_EXECUTED"},
    ]
    data["tdd_cycle"]["phase_execution_log"] = wrong_phases
    step_file = tmp_path / "wrong-phases.json"
    step_file.write_text(json.dumps(data, indent=2))
    return step_file


@pytest.fixture
def step_with_step_id(tmp_path) -> Path:
    """Create step file using obsolete 'step_id' instead of 'task_id'."""
    data = create_valid_step_file()
    del data["task_id"]
    data["step_id"] = "01-01"  # WRONG: obsolete field name
    step_file = tmp_path / "step-id.json"
    step_file.write_text(json.dumps(data, indent=2))
    return step_file


@pytest.fixture
def step_with_phase_id(tmp_path) -> Path:
    """Create step file with top-level 'phase_id' (wrong structure)."""
    data = create_valid_step_file()
    data["phase_id"] = "RED_ACCEPTANCE"  # WRONG: should not exist
    step_file = tmp_path / "phase-id.json"
    step_file.write_text(json.dumps(data, indent=2))
    return step_file


@pytest.fixture
def step_with_tdd_phase_no_cycle(tmp_path) -> Path:
    """Create step file with 'tdd_phase' at top level without 'tdd_cycle'."""
    data = create_valid_step_file()
    del data["tdd_cycle"]
    data["tdd_phase"] = "RED_ACCEPTANCE"  # WRONG: old structure
    step_file = tmp_path / "tdd-phase-no-cycle.json"
    step_file.write_text(json.dumps(data, indent=2))
    return step_file


@pytest.fixture
def step_missing_tdd_cycle(tmp_path) -> Path:
    """Create step file missing tdd_cycle section entirely."""
    data = create_valid_step_file()
    del data["tdd_cycle"]
    step_file = tmp_path / "missing-tdd-cycle.json"
    step_file.write_text(json.dumps(data, indent=2))
    return step_file


@pytest.fixture
def step_with_incomplete_phases(tmp_path) -> Path:
    """Create step file with less than 8 phases."""
    data = create_valid_step_file()
    # Only include 4 phases instead of 8
    data["tdd_cycle"]["phase_execution_log"] = [
        {"phase_name": "PREPARE", "phase_index": 0, "status": "NOT_EXECUTED"},
        {"phase_name": "RED_ACCEPTANCE", "phase_index": 1, "status": "NOT_EXECUTED"},
        {"phase_name": "RED_UNIT", "phase_index": 2, "status": "NOT_EXECUTED"},
        {"phase_name": "COMMIT", "phase_index": 3, "status": "NOT_EXECUTED"},
    ]
    step_file = tmp_path / "incomplete-phases.json"
    step_file.write_text(json.dumps(data, indent=2))
    return step_file


@pytest.fixture
def step_with_wrong_phase_index(tmp_path) -> Path:
    """Create step file with incorrect phase_index values."""
    data = create_valid_step_file()
    phases = create_valid_phase_execution_log()
    # Swap indices
    phases[1]["phase_index"] = 5  # Should be 1
    phases[5]["phase_index"] = 1  # Should be 5
    data["tdd_cycle"]["phase_execution_log"] = phases
    step_file = tmp_path / "wrong-index.json"
    step_file.write_text(json.dumps(data, indent=2))
    return step_file


@pytest.fixture
def step_with_invalid_status(tmp_path) -> Path:
    """Create step file with invalid status value."""
    data = create_valid_step_file()
    phases = create_valid_phase_execution_log()
    phases[0]["status"] = "INVALID_STATUS"  # Wrong: not in valid_statuses
    data["tdd_cycle"]["phase_execution_log"] = phases
    step_file = tmp_path / "invalid-status.json"
    step_file.write_text(json.dumps(data, indent=2))
    return step_file


# =============================================================================
# Unit Tests - REQUIRED_PHASES Constant Verification
# =============================================================================


class TestRequiredPhasesConstant:
    """Verify REQUIRED_PHASES constant matches expected format (8-phase schema v2.0)."""

    def test_has_exactly_8_phases(self):
        """Should define exactly 8 TDD phases (schema v2.0)."""
        assert len(REQUIRED_PHASES) == PHASE_COUNT

    def test_phases_match_expected_format(self):
        """Should match documented phase names exactly."""
        assert REQUIRED_PHASES == list(CORRECT_PHASE_NAMES)

    def test_no_parentheses_in_phase_names(self):
        """Phase names should NOT contain parentheses."""
        for phase in REQUIRED_PHASES:
            assert "(" not in phase, f"Phase '{phase}' contains parenthesis"
            assert ")" not in phase, f"Phase '{phase}' contains parenthesis"

    def test_uses_underscore_separator(self):
        """Multi-word phase names should use underscore separator."""
        multi_word_phases = [p for p in REQUIRED_PHASES if "_" in p]
        assert len(multi_word_phases) > 0, "Should have phases with underscores"
        # Verify specific expected underscored phases (8-phase schema v2.0)
        assert "RED_ACCEPTANCE" in REQUIRED_PHASES
        assert "RED_UNIT" in REQUIRED_PHASES
        assert "REFACTOR_CONTINUOUS" in REQUIRED_PHASES
        assert "REFACTOR_L4" in REQUIRED_PHASES

    def test_no_hyphens_in_phase_names(self):
        """Phase names should NOT use hyphens as separators."""
        for phase in REQUIRED_PHASES:
            assert "-" not in phase, f"Phase '{phase}' uses hyphen separator"

    def test_all_uppercase(self):
        """Phase names should be ALL UPPERCASE."""
        for phase in REQUIRED_PHASES:
            assert phase == phase.upper(), f"Phase '{phase}' is not uppercase"


# =============================================================================
# Unit Tests - Valid Step File Validation
# =============================================================================


class TestValidStepFileValidation:
    """Tests for validating correctly formatted step files."""

    def test_valid_step_file_passes_validation(self, valid_step_file):
        """Should pass validation for correctly formatted step file."""
        is_valid, issues = validate_step_file(valid_step_file)

        assert is_valid is True
        assert len(issues) == 0

    def test_valid_phase_execution_log_has_8_phases(self):
        """Valid phase_execution_log should have exactly 8 phases (schema v2.0)."""
        log = create_valid_phase_execution_log()
        issues = validate_phase_execution_log(log, "test.json")

        assert len(issues) == 0
        assert len(log) == PHASE_COUNT

    def test_valid_phase_execution_log_has_correct_indices(self):
        """Each phase should have correct phase_index matching position."""
        log = create_valid_phase_execution_log()
        issues = validate_phase_execution_log(log, "test.json")

        assert len(issues) == 0
        for i, entry in enumerate(log):
            assert entry["phase_index"] == i


# =============================================================================
# Unit Tests - Wrong Phase Name Detection
# =============================================================================


class TestWrongPhaseNameDetection:
    """Tests for detecting and rejecting wrong phase name formats."""

    def test_rejects_parentheses_format(self, step_with_wrong_phase_names):
        """Should reject phase names with parentheses like 'RED (Acceptance)'."""
        is_valid, issues = validate_step_file(step_with_wrong_phase_names)

        assert is_valid is False
        assert len(issues) > 0

        # Verify specific wrong phases detected
        missing_phases = [i for i in issues if "Missing phase:" in i]
        assert len(missing_phases) >= 3, "Should detect multiple missing phases"

    def test_detects_missing_red_acceptance(self, step_with_wrong_phase_names):
        """Should detect missing RED_ACCEPTANCE when 'RED (Acceptance)' used."""
        is_valid, issues = validate_step_file(step_with_wrong_phase_names)

        assert is_valid is False
        assert any("RED_ACCEPTANCE" in issue for issue in issues)

    def test_detects_missing_green(self, step_with_wrong_phase_names):
        """Should detect missing GREEN when 'GREEN (Unit)' used (8-phase schema)."""
        is_valid, issues = validate_step_file(step_with_wrong_phase_names)

        assert is_valid is False
        assert any("GREEN" in issue for issue in issues)

    @pytest.mark.parametrize(
        "wrong_name,correct_name",
        [
            ("RED (Acceptance)", "RED_ACCEPTANCE"),
            ("RED (Unit)", "RED_UNIT"),
            ("GREEN (Unit)", "GREEN"),
        ],
    )
    def test_wrong_name_not_recognized(self, tmp_path, wrong_name, correct_name):
        """Should NOT recognize wrong format phase names."""
        data = create_valid_step_file()
        # Replace correct name with wrong name
        for entry in data["tdd_cycle"]["phase_execution_log"]:
            if entry["phase_name"] == correct_name:
                entry["phase_name"] = wrong_name
                break

        step_file = tmp_path / "wrong-name.json"
        step_file.write_text(json.dumps(data, indent=2))

        is_valid, issues = validate_step_file(step_file)

        assert is_valid is False
        assert any(correct_name in issue for issue in issues)


# =============================================================================
# Unit Tests - Wrong Field Name Detection
# =============================================================================


class TestWrongFieldNameDetection:
    """Tests for detecting obsolete or wrong field names."""

    def test_rejects_step_id_field(self, step_with_step_id):
        """Should reject 'step_id' field - use 'task_id' instead."""
        is_valid, issues = validate_step_file(step_with_step_id)

        assert is_valid is False
        assert any("step_id" in issue.lower() for issue in issues)
        assert any("task_id" in issue.lower() for issue in issues)

    def test_rejects_phase_id_field(self, step_with_phase_id):
        """Should reject 'phase_id' at top level."""
        is_valid, issues = validate_step_file(step_with_phase_id)

        assert is_valid is False
        assert any("phase_id" in issue.lower() for issue in issues)

    def test_rejects_tdd_phase_without_tdd_cycle(self, step_with_tdd_phase_no_cycle):
        """Should reject 'tdd_phase' at top level without 'tdd_cycle'."""
        is_valid, issues = validate_step_file(step_with_tdd_phase_no_cycle)

        assert is_valid is False
        assert any("tdd_phase" in issue.lower() for issue in issues)


# =============================================================================
# Unit Tests - Missing tdd_cycle Detection
# =============================================================================


class TestMissingTddCycleDetection:
    """Tests for detecting missing tdd_cycle section."""

    def test_rejects_missing_tdd_cycle(self, step_missing_tdd_cycle):
        """Should reject step file without tdd_cycle section."""
        is_valid, issues = validate_step_file(step_missing_tdd_cycle)

        assert is_valid is False
        assert any("tdd_cycle" in issue.lower() for issue in issues)

    def test_error_message_indicates_critical(self, step_missing_tdd_cycle):
        """Error message should indicate tdd_cycle is CRITICAL."""
        is_valid, issues = validate_step_file(step_missing_tdd_cycle)

        assert is_valid is False
        assert any("CRITICAL" in issue for issue in issues)


# =============================================================================
# Unit Tests - Incomplete Phase Execution Log Detection
# =============================================================================


class TestIncompletePhaseLogDetection:
    """Tests for detecting incomplete phase_execution_log."""

    def test_rejects_less_than_8_phases(self, step_with_incomplete_phases):
        """Should reject phase_execution_log with fewer than 8 phases (schema v2.0)."""
        is_valid, issues = validate_step_file(step_with_incomplete_phases)

        assert is_valid is False
        assert any(f"expected {PHASE_COUNT}" in issue for issue in issues)

    def test_identifies_missing_phase_names(self, step_with_incomplete_phases):
        """Should identify which phases are missing."""
        is_valid, issues = validate_step_file(step_with_incomplete_phases)

        assert is_valid is False
        # Should detect all missing phases
        missing_phase_issues = [i for i in issues if "Missing phase:" in i]
        assert len(missing_phase_issues) >= 4  # 8 - 4 = 4 missing


# =============================================================================
# Unit Tests - Phase Index Validation
# =============================================================================


class TestPhaseIndexValidation:
    """Tests for validating phase_index values."""

    def test_rejects_wrong_phase_index(self, step_with_wrong_phase_index):
        """Should reject phases with incorrect phase_index values."""
        is_valid, issues = validate_step_file(step_with_wrong_phase_index)

        assert is_valid is False
        assert any("phase_index" in issue for issue in issues)

    def test_error_message_shows_expected_vs_actual(self, step_with_wrong_phase_index):
        """Error message should show expected vs actual index."""
        is_valid, issues = validate_step_file(step_with_wrong_phase_index)

        assert is_valid is False
        # Should have format like "phase_index is X, expected Y"
        index_issues = [i for i in issues if "phase_index" in i]
        assert len(index_issues) > 0
        assert any("expected" in i for i in index_issues)


# =============================================================================
# Unit Tests - Status Validation
# =============================================================================


class TestStatusValidation:
    """Tests for validating phase status values."""

    def test_rejects_invalid_status(self, step_with_invalid_status):
        """Should reject invalid status values."""
        is_valid, issues = validate_step_file(step_with_invalid_status)

        assert is_valid is False
        assert any("status" in issue.lower() for issue in issues)

    @pytest.mark.parametrize(
        "valid_status",
        ["NOT_EXECUTED", "IN_PROGRESS", "EXECUTED", "SKIPPED"],
    )
    def test_accepts_valid_statuses(self, tmp_path, valid_status):
        """Should accept all valid status values."""
        data = create_valid_step_file()
        for entry in data["tdd_cycle"]["phase_execution_log"]:
            entry["status"] = valid_status

        step_file = tmp_path / f"status-{valid_status.lower()}.json"
        step_file.write_text(json.dumps(data, indent=2))

        is_valid, issues = validate_step_file(step_file)

        assert is_valid is True
        assert len(issues) == 0


# =============================================================================
# Unit Tests - Empty and Null Values
# =============================================================================


class TestEmptyAndNullValues:
    """Tests for handling empty and null values."""

    def test_rejects_empty_phase_execution_log(self, tmp_path):
        """Should reject empty phase_execution_log array."""
        data = create_valid_step_file()
        data["tdd_cycle"]["phase_execution_log"] = []

        step_file = tmp_path / "empty-phases.json"
        step_file.write_text(json.dumps(data, indent=2))

        is_valid, issues = validate_step_file(step_file)

        assert is_valid is False
        assert any(
            "empty" in issue.lower() or "missing" in issue.lower() for issue in issues
        )

    def test_rejects_null_phase_execution_log(self, tmp_path):
        """Should reject null phase_execution_log."""
        data = create_valid_step_file()
        data["tdd_cycle"]["phase_execution_log"] = None

        step_file = tmp_path / "null-phases.json"
        step_file.write_text(json.dumps(data, indent=2))

        is_valid, issues = validate_step_file(step_file)

        assert is_valid is False


# =============================================================================
# Unit Tests - File Not Found and Invalid JSON
# =============================================================================


class TestFileErrors:
    """Tests for file-related errors."""

    def test_handles_nonexistent_file(self, tmp_path):
        """Should handle nonexistent file gracefully."""
        nonexistent = tmp_path / "does-not-exist.json"

        is_valid, issues = validate_step_file(nonexistent)

        assert is_valid is False
        assert len(issues) == 1
        assert "not found" in issues[0].lower() or "does not exist" in issues[0].lower()

    def test_handles_invalid_json(self, tmp_path):
        """Should handle invalid JSON gracefully."""
        invalid_json = tmp_path / "invalid.json"
        invalid_json.write_text("{ this is not valid json }")

        is_valid, issues = validate_step_file(invalid_json)

        assert is_valid is False
        assert len(issues) == 1
        assert "json" in issues[0].lower()


# =============================================================================
# Unit Tests - Required Fields Validation
# =============================================================================


class TestRequiredFieldsValidation:
    """Tests for required top-level fields validation."""

    @pytest.mark.parametrize(
        "missing_field",
        [
            "task_id",
            "project_id",
            "execution_agent",
            "self_contained_context",
            "task_specification",
            "dependencies",
            "state",
        ],
    )
    def test_detects_missing_required_field(self, tmp_path, missing_field):
        """Should detect each missing required field."""
        data = create_valid_step_file()
        del data[missing_field]

        step_file = tmp_path / f"missing-{missing_field}.json"
        step_file.write_text(json.dumps(data, indent=2))

        is_valid, issues = validate_step_file(step_file)

        assert is_valid is False
        assert any(missing_field in issue for issue in issues)


# =============================================================================
# Unit Tests - tdd_cycle Required Fields
# =============================================================================


class TestTddCycleRequiredFields:
    """Tests for required fields within tdd_cycle."""

    def test_detects_missing_acceptance_test(self, tmp_path):
        """Should detect missing acceptance_test in tdd_cycle."""
        data = create_valid_step_file()
        del data["tdd_cycle"]["acceptance_test"]

        step_file = tmp_path / "missing-acceptance-test.json"
        step_file.write_text(json.dumps(data, indent=2))

        is_valid, issues = validate_step_file(step_file)

        assert is_valid is False
        assert any("acceptance_test" in issue for issue in issues)

    def test_detects_missing_phase_execution_log(self, tmp_path):
        """Should detect missing phase_execution_log in tdd_cycle."""
        data = create_valid_step_file()
        del data["tdd_cycle"]["phase_execution_log"]

        step_file = tmp_path / "missing-phase-log.json"
        step_file.write_text(json.dumps(data, indent=2))

        is_valid, issues = validate_step_file(step_file)

        assert is_valid is False
        assert any("phase_execution_log" in issue for issue in issues)


# =============================================================================
# Unit Tests - Quality Gates and Phase Validation Rules
# =============================================================================


class TestOptionalSectionsValidation:
    """Tests for optional section validation."""

    def test_warns_missing_quality_gates(self, tmp_path):
        """Should report missing quality_gates section."""
        data = create_valid_step_file()
        del data["quality_gates"]

        step_file = tmp_path / "missing-quality-gates.json"
        step_file.write_text(json.dumps(data, indent=2))

        is_valid, issues = validate_step_file(step_file)

        assert is_valid is False
        assert any("quality_gates" in issue for issue in issues)

    def test_warns_missing_phase_validation_rules(self, tmp_path):
        """Should report missing phase_validation_rules section."""
        data = create_valid_step_file()
        del data["phase_validation_rules"]

        step_file = tmp_path / "missing-validation-rules.json"
        step_file.write_text(json.dumps(data, indent=2))

        is_valid, issues = validate_step_file(step_file)

        assert is_valid is False
        assert any("phase_validation_rules" in issue for issue in issues)


# =============================================================================
# Integration Tests - Multiple Issues Detection
# =============================================================================


class TestMultipleIssuesDetection:
    """Tests for detecting multiple issues in single file."""

    def test_detects_all_issues_in_badly_formatted_file(self, tmp_path):
        """Should detect multiple issues in badly formatted file."""
        data = {
            "step_id": "01-01",  # WRONG: should be task_id
            "phase_id": "RED",  # WRONG: should not exist
            "project_id": "test",
            "execution_agent": "@test",
            "self_contained_context": {},
            "task_specification": {},
            "dependencies": {},
            "state": {},
            "tdd_phase": "RED",  # WRONG: without tdd_cycle
        }

        step_file = tmp_path / "multiple-issues.json"
        step_file.write_text(json.dumps(data, indent=2))

        is_valid, issues = validate_step_file(step_file)

        assert is_valid is False
        assert len(issues) >= 3  # At least step_id, phase_id, and tdd_phase issues


# =============================================================================
# Test Execution Summary
# =============================================================================

if __name__ == "__main__":
    """
    Run tests with:
        pytest tests/test_step_file_format.py -v
        pytest tests/test_step_file_format.py -v --tb=short

    Expected coverage: >90% of step file format validation
    Expected execution time: <5 seconds
    """
    pytest.main([__file__, "-v", "--tb=short"])
