# =============================================================================
# nWave Framework Release Pipeline v1.0
# =============================================================================
#
# Architecture: Automated release workflow triggered on merge to main
#
# Trigger: Push to main branch (after PR merge)
#
# Stages:
#   1. Version Bump: Determine bump type from conventional commits
#   2. Build: Create release packages
#   3. Release: Publish GitHub Release with assets
#
# =============================================================================

name: Release Pipeline

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.gitignore'
      - 'LICENSE'

permissions:
  contents: write

env:
  PYTHON_VERSION: '3.12'
  PYTHONIOENCODING: 'utf-8'
  PYTHONUTF8: '1'

jobs:
  # ===========================================================================
  # STAGE 1: VERSION BUMP - Determine and apply version bump
  # ===========================================================================

  version-bump:
    name: "Version Bump"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      version: ${{ steps.bump.outputs.version }}
      previous_version: ${{ steps.bump.outputs.previous_version }}
      bump_type: ${{ steps.bump.outputs.bump_type }}
      changelog: ${{ steps.changelog.outputs.changelog }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: pip install pyyaml toml packaging

      - name: Get previous version
        id: previous
        run: |
          # Get version from pyproject.toml
          VERSION=$(python3 -c "import toml; print(toml.load('pyproject.toml')['project']['version'])")
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Previous version: ${VERSION}"

      - name: Analyze commits for bump type
        id: analyze
        run: |
          python3 << 'EOF'
          import subprocess
          import sys
          import os

          # Try to get commits since last tag (preferred method)
          # This ensures we capture ALL commits since the last release
          last_tag_result = subprocess.run(
              ['git', 'describe', '--tags', '--abbrev=0'],
              capture_output=True,
              text=True
          )

          method_used = ""
          if last_tag_result.returncode == 0:
              last_tag = last_tag_result.stdout.strip()
              result = subprocess.run(
                  ['git', 'log', '--format=%s%n%b', f'{last_tag}..HEAD'],
                  capture_output=True,
                  text=True
              )
              method_used = f"tag-based ({last_tag}..HEAD)"
          else:
              # Fallback: no tags exist yet, use recent commits
              # This is expected for first release or fresh repos
              result = subprocess.run(
                  ['git', 'log', '--format=%s%n%b', 'HEAD~20..HEAD'],
                  capture_output=True,
                  text=True
              )
              method_used = "fallback (HEAD~20..HEAD, no previous tags found)"

          commits = result.stdout

          # Log which method was used for transparency
          print(f"::notice::Version bump detection method: {method_used}")

          # Determine bump type
          bump_type = "patch"  # default

          if "BREAKING CHANGE" in commits or "!:" in commits:
              bump_type = "major"
          elif any(line.startswith("feat") for line in commits.split('\n')):
              bump_type = "minor"

          print(f"Determined bump type: {bump_type}")

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"bump_type={bump_type}\n")
              f.write(f"method_used={method_used}\n")
          EOF

      - name: Calculate new version
        id: bump
        run: |
          python3 << 'EOF'
          import os
          from packaging.version import Version

          previous = "${{ steps.previous.outputs.version }}"
          bump_type = "${{ steps.analyze.outputs.bump_type }}"

          v = Version(previous)

          if bump_type == "major":
              new_version = f"{v.major + 1}.0.0"
          elif bump_type == "minor":
              new_version = f"{v.major}.{v.minor + 1}.0"
          else:
              new_version = f"{v.major}.{v.minor}.{v.micro + 1}"

          print(f"New version: {new_version}")

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"version={new_version}\n")
              f.write(f"previous_version={previous}\n")
              f.write(f"bump_type={bump_type}\n")
          EOF

      - name: Generate changelog
        id: changelog
        run: |
          python3 << 'EOF'
          import subprocess
          import os
          from datetime import date

          version = "${{ steps.bump.outputs.version }}"
          previous = "${{ steps.bump.outputs.previous_version }}"

          # Get commits since last tag or recent commits
          result = subprocess.run(
              ['git', 'log', '--format=%s|%h', f'v{previous}..HEAD' if previous else 'HEAD~20..HEAD'],
              capture_output=True,
              text=True
          )

          if result.returncode != 0:
              # Fallback: get recent commits
              result = subprocess.run(
                  ['git', 'log', '--format=%s|%h', '-20'],
                  capture_output=True,
                  text=True
              )

          commits = result.stdout.strip().split('\n')

          # Categorize commits
          features = []
          fixes = []
          breaking = []
          docs = []
          other = []

          for line in commits:
              if not line.strip() or '|' not in line:
                  continue
              msg, hash = line.rsplit('|', 1)
              msg = msg.strip()
              hash = hash.strip()

              if msg.startswith('feat'):
                  features.append(f"- {msg} ({hash})")
              elif msg.startswith('fix'):
                  fixes.append(f"- {msg} ({hash})")
              elif 'BREAKING' in msg or '!:' in msg:
                  breaking.append(f"- {msg} ({hash})")
              elif msg.startswith('docs'):
                  docs.append(f"- {msg} ({hash})")
              elif not msg.startswith('chore(release)'):
                  other.append(f"- {msg} ({hash})")

          # Build changelog
          changelog = f"## v{version} ({date.today().isoformat()})\n\n"

          if breaking:
              changelog += "### Breaking Changes\n" + '\n'.join(breaking) + "\n\n"
          if features:
              changelog += "### Features\n" + '\n'.join(features) + "\n\n"
          if fixes:
              changelog += "### Bug Fixes\n" + '\n'.join(fixes) + "\n\n"
          if docs:
              changelog += "### Documentation\n" + '\n'.join(docs) + "\n\n"
          if other:
              changelog += "### Other Changes\n" + '\n'.join(other) + "\n\n"

          # Write to file for release notes
          with open('CHANGELOG_RELEASE.md', 'w') as f:
              f.write(changelog)

          # Output for GitHub Actions (escape newlines)
          changelog_escaped = changelog.replace('\n', '%0A').replace('\r', '%0D')
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"changelog<<CHANGELOG_EOF\n{changelog}\nCHANGELOG_EOF\n")

          print(changelog)
          EOF

      - name: Update version in pyproject.toml
        run: |
          python3 << 'EOF'
          import toml

          version = "${{ steps.bump.outputs.version }}"

          # Update pyproject.toml
          with open('pyproject.toml', 'r') as f:
              config = toml.load(f)

          config['project']['version'] = version

          with open('pyproject.toml', 'w') as f:
              toml.dump(config, f)

          print(f"Updated pyproject.toml to version {version}")
          EOF

      - name: Update version in framework-catalog.yaml
        run: |
          python3 << 'EOF'
          import yaml

          version = "${{ steps.bump.outputs.version }}"

          with open('nWave/framework-catalog.yaml', 'r') as f:
              catalog = yaml.safe_load(f)

          catalog['version'] = version

          with open('nWave/framework-catalog.yaml', 'w') as f:
              yaml.dump(catalog, f, default_flow_style=False, sort_keys=False)

          print(f"Updated framework-catalog.yaml to version {version}")
          EOF

      - name: Commit version bump
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add pyproject.toml nWave/framework-catalog.yaml
          git commit -m "chore(release): bump version to ${{ steps.bump.outputs.version }}" || echo "No changes to commit"
          git push

      - name: Upload changelog artifact
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: CHANGELOG_RELEASE.md
          retention-days: 1

  # ===========================================================================
  # STAGE 2: BUILD - Create release packages
  # ===========================================================================

  build:
    name: "Build Distribution"
    needs: [version-bump]
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Pull latest (with version bump)
        run: git pull origin main

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python3 -m pip install --upgrade pip setuptools wheel pipenv
          pipenv install --dev

      - name: Build IDE bundle
        run: |
          PYTHONPATH=tools pipenv run python3 tools/core/build_ide_bundle.py \
            --source-dir nWave \
            --output-dir dist/ide \
            --clean \
            --verbose

      - name: Create release packages
        run: |
          pipenv run python3 tools/create_release_packages.py \
            --version ${{ needs.version-bump.outputs.version }} \
            --output-dir dist/releases

      - name: Generate checksums (Pure Python)
        run: |
          python3 << 'EOF'
          import hashlib
          from pathlib import Path

          releases_dir = Path('dist/releases')
          checksums = []

          for file in sorted(releases_dir.glob('*')):
              if file.is_file() and file.name != 'SHA256SUMS.txt':
                  sha256 = hashlib.sha256()
                  with open(file, 'rb') as f:
                      for chunk in iter(lambda: f.read(8192), b''):
                          sha256.update(chunk)
                  checksums.append(f"{sha256.hexdigest()}  {file.name}")

          with open(releases_dir / 'SHA256SUMS.txt', 'w') as f:
              f.write('\n'.join(checksums) + '\n')

          print("Generated checksums:")
          for line in checksums:
              print(f"  {line}")
          EOF

      - name: Verify package structure
        run: |
          python3 << 'EOF'
          from pathlib import Path
          import sys

          releases_dir = Path('dist/releases')
          version = "${{ needs.version-bump.outputs.version }}"

          required_files = [
              f'nwave-{version}-claude-code.tar.gz',
              f'install-nwave-claude-code.py',
              'SHA256SUMS.txt'
          ]

          missing = []
          for f in required_files:
              if not (releases_dir / f).exists():
                  missing.append(f)

          if missing:
              print(f"::error::Missing required files: {missing}")
              sys.exit(1)

          print(f"::notice::All required files present")
          for f in sorted(releases_dir.glob('*')):
              print(f"  - {f.name}")
          EOF

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-packages
          path: dist/releases/*
          retention-days: 90

  # ===========================================================================
  # STAGE 3: RELEASE - Create GitHub Release
  # ===========================================================================

  release:
    name: "GitHub Release"
    needs: [version-bump, build]
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Pull latest
        run: git pull origin main

      - uses: actions/download-artifact@v4
        with:
          name: release-packages
          path: dist/releases

      - uses: actions/download-artifact@v4
        with:
          name: changelog
          path: .

      - name: Create Git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          VERSION="${{ needs.version-bump.outputs.version }}"

          git tag -a "v${VERSION}" -m "Release v${VERSION}"
          git push origin "v${VERSION}"

      - name: Generate release notes
        run: |
          VERSION="${{ needs.version-bump.outputs.version }}"
          RELEASE_DATE=$(date +%Y-%m-%d)

          cat > RELEASE_NOTES.md << 'NOTES_EOF'
          # nWave Framework v${{ needs.version-bump.outputs.version }}

          ## Release Information

          - **Version**: ${{ needs.version-bump.outputs.version }}
          - **Release Date**: $(date +%Y-%m-%d)
          - **Bump Type**: ${{ needs.version-bump.outputs.bump_type }}
          - **Previous Version**: ${{ needs.version-bump.outputs.previous_version }}

          ## Installation

          ### Quick Install (Claude Code)
          ```bash
          curl -O https://github.com/${{ github.repository }}/releases/download/v${{ needs.version-bump.outputs.version }}/install-nwave-claude-code.py
          python3 install-nwave-claude-code.py
          ```

          ### Update Existing Installation
          Run `/nw:update` in Claude Code to update to this version.

          ## What's New

          NOTES_EOF

          cat CHANGELOG_RELEASE.md >> RELEASE_NOTES.md

          cat >> RELEASE_NOTES.md << 'NOTES_EOF'

          ## Quality Assurance

          This release passed all quality gates:
          - Conventional commit validation
          - Ruff lint and format checks
          - YAML/JSON syntax validation
          - Framework catalog validation
          - Cross-platform tests (Linux, Windows, macOS)
          - Multi-Python version tests (3.11, 3.12)
          - Agent synchronization verification

          ## Checksums

          SHA256 checksums are available in `SHA256SUMS.txt` for verification.
          NOTES_EOF

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.version-bump.outputs.version }}
          name: nWave Framework v${{ needs.version-bump.outputs.version }}
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: false
          files: |
            dist/releases/*.tar.gz
            dist/releases/*.py
            dist/releases/SHA256SUMS.txt
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify released assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.version-bump.outputs.version }}"

          echo "Verifying assets for release v${VERSION}..."

          # Define expected assets
          EXPECTED_ASSETS=(
            "nwave-${VERSION}-claude-code.tar.gz"
            "install-nwave-claude-code.py"
            "SHA256SUMS.txt"
          )

          # Get actual assets from the release
          ACTUAL_ASSETS=$(gh release view "v${VERSION}" --json assets -q '.assets[].name')

          # Verify each expected asset exists
          MISSING_ASSETS=()
          for asset in "${EXPECTED_ASSETS[@]}"; do
            if echo "$ACTUAL_ASSETS" | grep -q "^${asset}$"; then
              echo "::notice::Asset verified: ${asset}"
            else
              echo "::error::Missing asset: ${asset}"
              MISSING_ASSETS+=("$asset")
            fi
          done

          # Fail if any assets are missing
          if [ ${#MISSING_ASSETS[@]} -gt 0 ]; then
            echo "::error::Release verification failed - ${#MISSING_ASSETS[@]} asset(s) missing"
            exit 1
          fi

          echo "::notice::All ${#EXPECTED_ASSETS[@]} expected assets verified successfully"

      - name: Release Summary
        run: |
          echo "## Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.version-bump.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Bump Type**: ${{ needs.version-bump.outputs.bump_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Previous**: ${{ needs.version-bump.outputs.previous_version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Assets Uploaded and Verified" >> $GITHUB_STEP_SUMMARY
          ls -la dist/releases/ | tail -n +2 >> $GITHUB_STEP_SUMMARY
