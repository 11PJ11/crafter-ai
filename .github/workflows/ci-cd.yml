# =============================================================================
# nWave Framework CI/CD Pipeline v2.0
# =============================================================================
#
# Architecture: Optimized parallel execution with intelligent grouping
#
# Stage 1 - Fast Checks (parallel, ~1 min):
#   - gitlint: Conventional commits validation (Python-based)
#   - code-quality: Ruff lint + format
#   - file-quality: Whitespace, EOF, YAML, JSON syntax
#   - security: Merge conflicts, private keys, shell prevention
#
# Stage 2 - Framework Validation (parallel, ~2 min):
#   - framework-validation: YAML schema, docs version, freshness, conflicts
#
# Stage 3 - Cross-Platform Tests (parallel matrix, ~10 min):
#   - test: 3 OS x 2 Python versions = 6 jobs
#
# Stage 4 - Agent Validation (~1 min):
#   - agent-sync: Verify agent name synchronization
#
# Stage 5 - Build (tags only, ~5 min):
#   - build: Create release packages
#
# Stage 6 - Release (tags only, ~2 min):
#   - release: Publish to GitHub Releases
#
# =============================================================================

name: CI/CD Pipeline

on:
  push:
    branches:
      - master
      - develop
      - installer
    tags:
      - 'v*'
  pull_request:
    branches:
      - master
      - develop

permissions:
  contents: write
  pull-requests: read

env:
  PYTHON_DEFAULT: '3.12'
  CACHE_VERSION: v3
  PYTHONIOENCODING: 'utf-8'
  PYTHONUTF8: '1'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ===========================================================================
  # STAGE 1: FAST CHECKS - Run in parallel on Linux (~1 minute total)
  # ===========================================================================

  commitlint:
    name: "Commit Messages"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Install gitlint
        run: pip install gitlint

      - name: Validate commit messages
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            gitlint --commits "${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }}"
          elif [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
            # Validate that 'before' commit exists in repository
            if git cat-file -e "${{ github.event.before }}" 2>/dev/null; then
              gitlint --commits "${{ github.event.before }}..${{ github.sha }}"
            else
              echo "::warning::Commit ${{ github.event.before }} not found (likely due to force push/amend). Validating HEAD commit only."
              gitlint
            fi
          else
            gitlint
          fi

  code-quality:
    name: "Code Quality (Ruff)"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Install ruff
        run: pip install ruff

      - name: Ruff lint
        run: ruff check scripts/ tools/ tests/ --exit-non-zero-on-fix

      - name: Ruff format check
        run: ruff format --check --diff scripts/ tools/ tests/

  file-quality:
    name: "File Quality"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Install PyYAML
        run: pip install pyyaml

      - name: Check trailing whitespace
        run: |
          if git ls-files | xargs grep -l '[[:blank:]]$' 2>/dev/null | grep -v -E '^(dist/|\.git/)'; then
            echo "::error::Files with trailing whitespace found"
            exit 1
          fi
          echo "::notice::No trailing whitespace found"

      - name: Check end of file newlines
        run: |
          failed=0
          for file in $(git ls-files | grep -v -E '^(dist/|\.git/)' | head -200); do
            if [ -f "$file" ] && [ -s "$file" ]; then
              if [ "$(tail -c 1 "$file" | wc -l)" -eq 0 ]; then
                echo "::error file=$file::Missing newline at end of file"
                failed=1
              fi
            fi
          done
          [ $failed -eq 0 ] && echo "::notice::All files have proper end-of-file newlines"
          exit $failed

      - name: Check YAML syntax
        run: |
          python3 << 'EOF'
          import yaml
          import sys
          from pathlib import Path

          errors = []
          for pattern in ['*.yaml', '*.yml']:
              for yaml_file in Path('.').rglob(pattern):
                  if '.git' in str(yaml_file) or 'dist' in str(yaml_file):
                      continue
                  try:
                      with open(yaml_file) as f:
                          yaml.safe_load(f)
                  except yaml.YAMLError as e:
                      errors.append(f'{yaml_file}: {e}')

          if errors:
              for e in errors:
                  print(f'::error::{e}')
              sys.exit(1)
          print('::notice::All YAML files have valid syntax')
          EOF

      - name: Check JSON syntax
        run: |
          python3 << 'EOF'
          import json
          import sys
          from pathlib import Path

          errors = []
          for json_file in Path('.').rglob('*.json'):
              if '.git' in str(json_file) or 'dist' in str(json_file) or 'node_modules' in str(json_file):
                  continue
              try:
                  with open(json_file) as f:
                      json.load(f)
              except json.JSONDecodeError as e:
                  errors.append(f'{json_file}: {e}')

          if errors:
              for e in errors:
                  print(f'::error::{e}')
              sys.exit(1)
          print('::notice::All JSON files have valid syntax')
          EOF

  security-checks:
    name: "Security Checks"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Check for merge conflict markers
        run: |
          if git ls-files | xargs grep -l -E '^(<<<<<<<|=======|>>>>>>>)' 2>/dev/null; then
            echo "::error::Merge conflict markers found in repository"
            exit 1
          fi
          echo "::notice::No merge conflict markers found"

      - name: Detect private keys
        run: |
          if git ls-files | xargs grep -l -E '-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----' 2>/dev/null; then
            echo "::error::Private key detected in repository"
            exit 1
          fi
          echo "::notice::No private keys detected"

      - name: Prevent shell scripts
        run: python3 scripts/hooks/prevent_shell_scripts.py

  # ===========================================================================
  # STAGE 2: FRAMEWORK VALIDATION - Depends on Stage 1
  # ===========================================================================

  framework-validation:
    name: "Framework Validation"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [commitlint, code-quality, file-quality, security-checks]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Install dependencies
        run: pip install pyyaml packaging

      - name: Validate framework-catalog.yaml
        run: |
          python3 << 'EOF'
          import yaml
          import sys
          import re

          with open('nWave/framework-catalog.yaml', 'r') as f:
              catalog = yaml.safe_load(f)

          required_fields = ['name', 'version', 'description', 'agents', 'commands']
          missing = [f for f in required_fields if f not in catalog]

          if missing:
              print(f'::error::Missing required fields in framework-catalog.yaml: {missing}')
              sys.exit(1)

          version = catalog['version']
          if not re.match(r'^\d+\.\d+\.\d+$', version):
              print(f'::error::Invalid version format: {version}')
              sys.exit(1)

          print(f'::notice::framework-catalog.yaml validation passed (version: {version})')
          EOF

      - name: Validate documentation version
        run: python3 scripts/hooks/validate_docs.py

      - name: Check documentation freshness
        run: python3 scripts/hooks/check_documentation_freshness.py

      - name: Detect file conflicts
        run: python3 scripts/hooks/detect_conflicts.py

  # ===========================================================================
  # STAGE 3: CROSS-PLATFORM TESTS - Depends on Framework Validation
  # ===========================================================================

  test:
    name: "Test - Py${{ matrix.python-version }} / ${{ matrix.os }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    needs: [framework-validation]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: ['3.11', '3.12']

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Configure Windows console for UTF-8
        if: runner.os == 'Windows'
        run: |
          chcp 65001
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        shell: pwsh

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/Library/Caches/pip
            ~\AppData\Local\pip\Cache
          key: ${{ runner.os }}-pip-${{ env.CACHE_VERSION }}-${{ matrix.python-version }}-${{ hashFiles('Pipfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ env.CACHE_VERSION }}-${{ matrix.python-version }}-
            ${{ runner.os }}-pip-${{ env.CACHE_VERSION }}-

      - name: Install pipenv and dependencies
        run: |
          python3 -m pip install --upgrade pip setuptools wheel pipenv
          pipenv install --dev --deploy --ignore-pipfile || pipenv install --dev
        shell: bash

      - name: Install commit-msg hook
        run: |
          python3 << 'EOF'
          import shutil
          from pathlib import Path
          import platform
          import stat

          src = Path('scripts/hooks/commit-msg')
          dest = Path('.git/hooks/commit-msg')
          shutil.copy(src, dest)

          if platform.system() != 'Windows':
              dest.chmod(dest.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

          print('Installed commit-msg hook')
          EOF
        shell: bash

      - name: Run pytest test suite
        run: |
          pipenv run pytest tests/ \
            --verbose \
            --tb=short \
            --cov=. \
            --cov-report=term-missing \
            --cov-report=xml \
            --cov-report=html \
            --junitxml=test-results-${{ matrix.os }}-py${{ matrix.python-version }}.xml
        shell: bash

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.os }}-py${{ matrix.python-version }}
          path: test-results-*.xml
          retention-days: 14

      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.os }}-py${{ matrix.python-version }}
          path: |
            coverage.xml
            htmlcov/
          retention-days: 14

      - name: Test Summary
        if: success()
        run: |
          echo "## Test Summary - Python ${{ matrix.python-version }} on ${{ matrix.os }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All tests passed" >> $GITHUB_STEP_SUMMARY
        shell: bash

  # ===========================================================================
  # STAGE 4: AGENT VALIDATION - Depends on Tests
  # ===========================================================================

  agent-sync:
    name: "Agent Sync Validation"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [test]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Install pipenv and dependencies
        run: |
          python3 -m pip install --upgrade pip pipenv
          pipenv install --dev --deploy --ignore-pipfile || pipenv install --dev

      - name: Verify agent name synchronization
        run: pipenv run python3 scripts/framework/sync_agent_names.py --verify

  # ===========================================================================
  # STAGE 5: BUILD - Only on Version Tags
  # ===========================================================================

  build:
    name: "Build Distribution"
    needs: [agent-sync]
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Install build dependencies
        run: |
          python3 -m pip install --upgrade pip setuptools wheel pipenv
          pipenv install --dev

      - name: Extract version from tag
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT

      - name: Verify version consistency
        run: |
          TAG_VERSION="${{ steps.get_version.outputs.VERSION }}"
          CATALOG_VERSION=$(pipenv run python3 -c "import yaml; print(yaml.safe_load(open('nWave/framework-catalog.yaml'))['version'])")

          if [ "$TAG_VERSION" != "$CATALOG_VERSION" ]; then
            echo "::error::Version mismatch - tag: ${TAG_VERSION}, catalog: ${CATALOG_VERSION}"
            exit 1
          fi

      - name: Build IDE bundle
        run: |
          PYTHONPATH=tools pipenv run python3 tools/core/build_ide_bundle.py \
            --source-dir nWave \
            --output-dir dist/ide \
            --clean \
            --verbose

      - name: Create release packages
        run: |
          pipenv run python3 tools/create_release_packages.py \
            --version ${{ steps.get_version.outputs.VERSION }} \
            --output-dir dist/releases

      - name: Generate checksums
        run: |
          cd dist/releases
          sha256sum * > SHA256SUMS.txt
          cat SHA256SUMS.txt

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-packages
          path: dist/releases/*
          retention-days: 90

  # ===========================================================================
  # STAGE 6: RELEASE - Only on Version Tags
  # ===========================================================================

  release:
    name: "GitHub Release"
    needs: [build]
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: release-packages
          path: dist/releases

      - name: Extract version
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT

      - name: Generate release notes
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          RELEASE_DATE=$(date +%Y-%m-%d)

          cat > dist/releases/RELEASE_NOTES.md << EOF
          # nWave Framework v${VERSION}

          ## Release Information

          - **Version**: ${VERSION}
          - **Release Date**: ${RELEASE_DATE}
          - **Methodology**: DISCUSS > DESIGN > DISTILL > DEVELOP > DELIVER

          ## Installation

          \`\`\`bash
          curl -O https://github.com/${{ github.repository }}/releases/download/v${VERSION}/install-nwave-claude-code.py
          python install-nwave-claude-code.py
          \`\`\`

          ## Quality Assurance

          This release has passed all quality gates:
          - Conventional commit validation
          - Ruff lint and format checks
          - YAML/JSON syntax validation
          - Framework catalog validation
          - Documentation validation
          - Cross-platform tests (Linux, Windows, macOS)
          - Multi-Python version tests (3.11, 3.12)
          - Agent synchronization verification
          EOF

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          name: nWave Framework v${{ steps.get_version.outputs.VERSION }}
          body_path: dist/releases/RELEASE_NOTES.md
          draft: false
          prerelease: ${{ contains(github.ref, '-beta') || contains(github.ref, '-rc') || contains(github.ref, '-alpha') }}
          files: |
            dist/releases/*.tar.gz
            dist/releases/*.py
            dist/releases/SHA256SUMS.txt
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ===========================================================================
  # NOTIFICATION: SLACK ALERTS - RED on failure, GREEN on recovery
  # ===========================================================================

  notify-slack:
    name: "Slack Notification"
    runs-on: ubuntu-latest
    timeout-minutes: 3
    # Run on BOTH failure AND success (to detect RED‚ÜíGREEN transitions)
    # Now triggers on ALL branches - @mentions ensure no spam (each dev gets notified for their branches only)
    if: |
      always() &&
      !cancelled()
    needs: [commitlint, code-quality, file-quality, security-checks, framework-validation, test, agent-sync, build, release]

    steps:
      - name: Checkout (for state tracking script)
        uses: actions/checkout@v4

      - name: Determine current status
        id: current-status
        run: |
          # Check if any job failed
          NEEDS_CONTEXT='${{ toJson(needs) }}'
          echo "Needs context: $NEEDS_CONTEXT"

          if echo "$NEEDS_CONTEXT" | jq -e '.[] | select(.result == "failure")' > /dev/null; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "Current run: FAILURE"
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "Current run: SUCCESS"
          fi

      - name: Load previous run state
        id: previous-state
        uses: actions/cache/restore@v4
        with:
          path: .pipeline-state
          key: pipeline-state-${{ github.ref }}-never-match
          restore-keys: |
            pipeline-state-${{ github.ref }}-

      - name: Determine notification type
        id: notification-type
        run: |
          CURRENT="${{ steps.current-status.outputs.status }}"

          # Load previous status
          if [ -f .pipeline-state/status.txt ]; then
            PREVIOUS=$(cat .pipeline-state/status.txt)
            echo "Previous run status: $PREVIOUS"
          else
            PREVIOUS="unknown"
            echo "No previous run status found"
          fi

          echo "Current: $CURRENT, Previous: $PREVIOUS"

          # Determine notification type based on state transition
          if [[ "$CURRENT" == "failure" ]]; then
            echo "type=failure" >> $GITHUB_OUTPUT
            echo "should_notify=true" >> $GITHUB_OUTPUT
            echo "Will send RED notification"
          elif [[ "$CURRENT" == "success" && "$PREVIOUS" == "failure" ]]; then
            echo "type=back_to_green" >> $GITHUB_OUTPUT
            echo "should_notify=true" >> $GITHUB_OUTPUT
            echo "Will send GREEN notification (recovery)"
          else
            echo "type=none" >> $GITHUB_OUTPUT
            echo "should_notify=false" >> $GITHUB_OUTPUT
            echo "No notification needed (already green)"
          fi

      - name: Parse failed jobs
        id: failed-jobs
        if: steps.current-status.outputs.status == 'failure'
        run: |
          NEEDS_CONTEXT='${{ toJson(needs) }}'

          # Extract failed job names
          FAILED_JOBS=$(echo "$NEEDS_CONTEXT" | jq -r '
            to_entries
            | map(select(.value.result == "failure"))
            | map("‚Ä¢ " + .key)
            | join("\n")
          ')

          if [ -z "$FAILED_JOBS" ]; then
            FAILED_JOBS="‚Ä¢ Multiple jobs failed"
          fi

          echo "Failed jobs:"
          echo "$FAILED_JOBS"

          # Store for Slack payload (escape for JSON)
          echo "jobs<<EOF" >> $GITHUB_OUTPUT
          echo "$FAILED_JOBS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Load failure metadata for GREEN notification
        id: failure-metadata
        if: steps.notification-type.outputs.type == 'back_to_green'
        run: |
          if [ -f .pipeline-state/failure-time.txt ]; then
            FAILURE_TIME=$(cat .pipeline-state/failure-time.txt)
            echo "failure_time=$FAILURE_TIME" >> $GITHUB_OUTPUT

            # Calculate time since failure
            CURRENT_TIME=$(date +%s)
            TIME_DIFF=$((CURRENT_TIME - FAILURE_TIME))

            # Format time difference (smart: 5 min, 18 minutes, 2h 34m, 1d 3h)
            if [ $TIME_DIFF -lt 60 ]; then
              TIME_DISPLAY="${TIME_DIFF} sec"
            elif [ $TIME_DIFF -lt 3600 ]; then
              MINUTES=$((TIME_DIFF / 60))
              if [ $MINUTES -eq 1 ]; then
                TIME_DISPLAY="1 minute"
              else
                TIME_DISPLAY="${MINUTES} minutes"
              fi
            elif [ $TIME_DIFF -lt 86400 ]; then
              HOURS=$((TIME_DIFF / 3600))
              MINUTES=$(((TIME_DIFF % 3600) / 60))
              TIME_DISPLAY="${HOURS}h ${MINUTES}m"
            else
              DAYS=$((TIME_DIFF / 86400))
              HOURS=$(((TIME_DIFF % 86400) / 3600))
              TIME_DISPLAY="${DAYS}d ${HOURS}h"
            fi

            echo "time_since_failure=$TIME_DISPLAY" >> $GITHUB_OUTPUT
          else
            echo "time_since_failure=unknown" >> $GITHUB_OUTPUT
          fi

          # Load failed jobs from previous RED notification
          if [ -f .pipeline-state/failed-jobs.txt ]; then
            FAILED_JOBS=$(cat .pipeline-state/failed-jobs.txt | sed 's/^‚Ä¢ /‚Ä¢ /; s/$/ ‚úÖ now passing/')
            echo "previously_failed<<EOF" >> $GITHUB_OUTPUT
            echo "$FAILED_JOBS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "previously_failed=‚Ä¢ All jobs ‚úÖ now passing" >> $GITHUB_OUTPUT
          fi

      - name: Map git author to Slack user ID
        id: slack-author
        run: |
          GIT_AUTHOR="${{ github.actor }}"

          # Author mapping (git username ‚Üí Slack user ID)
          case "$GIT_AUTHOR" in
            "undeadgrishnackh")
              SLACK_USER="<@U05HX4GEVGR>"  # michele.brissoni@brix.consulting
              ;;
            "11PJ11")
              SLACK_USER="<@U07G5FJBN85>"  # alessandro.digioia@brix.consulting
              ;;
            *)
              SLACK_USER="$GIT_AUTHOR"  # Fallback to plaintext
              echo "::warning::Author mapping missing for '$GIT_AUTHOR'"
              ;;
          esac

          echo "author=$SLACK_USER" >> $GITHUB_OUTPUT
          echo "Slack author: $SLACK_USER"

      - name: Truncate commit message
        id: commit-msg
        run: |
          MSG="${{ github.event.head_commit.message }}"
          FIRST_LINE=$(echo "$MSG" | head -1)

          if [ ${#FIRST_LINE} -gt 100 ]; then
            TRUNCATED="${FIRST_LINE:0:97}..."
          else
            TRUNCATED="$FIRST_LINE"
          fi

          echo "message=$TRUNCATED" >> $GITHUB_OUTPUT

      - name: Get current timestamp
        id: timestamp
        run: |
          CURRENT_TIMESTAMP=$(date +%s)
          echo "unix=$CURRENT_TIMESTAMP" >> $GITHUB_OUTPUT
          echo "Current Unix timestamp: $CURRENT_TIMESTAMP"

      - name: Send RED notification (failure)
        if: steps.notification-type.outputs.type == 'failure'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook-type: incoming-webhook
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "üî¥ Pipeline Failed: ${{ github.workflow }}",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n${{ github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Author:*\n${{ steps.slack-author.outputs.author }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üìù *${{ steps.commit-msg.outputs.message }}*\nCommit: `${{ github.sha }}`"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*‚ùå Failed Jobs:*\n${{ steps.failed-jobs.outputs.jobs }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Run"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
                      "style": "danger"
                    },
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Commit"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
                    }
                  ]
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "‚è±Ô∏è Failed at: <!date^${{ steps.timestamp.outputs.unix }}^{date_short_pretty} at {time}|timestamp>"
                    }
                  ]
                }
              ]
            }

      - name: Send GREEN notification (recovery)
        if: steps.notification-type.outputs.type == 'back_to_green'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook-type: incoming-webhook
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "‚úÖ Pipeline Recovered: ${{ github.workflow }}",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n${{ github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Fixed by:*\n${{ steps.slack-author.outputs.author }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üìù *${{ steps.commit-msg.outputs.message }}*\nCommit: `${{ github.sha }}`"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üéâ *Back to green* after ${{ steps.failure-metadata.outputs.time_since_failure }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Previously failed:*\n${{ steps.failure-metadata.outputs.previously_failed }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Run"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
                      "style": "primary"
                    },
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Commit"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
                    }
                  ]
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "üü¢ All systems healthy"
                    }
                  ]
                }
              ]
            }

      - name: Save current state for next run
        if: always()
        run: |
          mkdir -p .pipeline-state
          echo "${{ steps.current-status.outputs.status }}" > .pipeline-state/status.txt

          # If failure, save metadata for future GREEN notification
          if [[ "${{ steps.current-status.outputs.status }}" == "failure" ]]; then
            date +%s > .pipeline-state/failure-time.txt
            echo "${{ steps.failed-jobs.outputs.jobs }}" > .pipeline-state/failed-jobs.txt
          fi

          # If success, clear failure metadata
          if [[ "${{ steps.current-status.outputs.status }}" == "success" ]]; then
            rm -f .pipeline-state/failure-time.txt
            rm -f .pipeline-state/failed-jobs.txt
          fi

      - name: Cache current state
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .pipeline-state
          key: pipeline-state-${{ github.ref }}-${{ github.run_id }}
