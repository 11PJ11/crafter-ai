# =============================================================================
# nWave Framework CI/CD Pipeline v2.0
# =============================================================================
#
# Architecture: Optimized parallel execution with intelligent grouping
#
# Stage 1 - Fast Checks (parallel, ~1 min):
#   - commitlint: Conventional commits validation
#   - code-quality: Ruff lint + format
#   - file-quality: Whitespace, EOF, YAML, JSON syntax
#   - security: Merge conflicts, private keys, shell prevention
#
# Stage 2 - Framework Validation (parallel, ~2 min):
#   - framework-validation: YAML schema, docs version, freshness, conflicts
#
# Stage 3 - Cross-Platform Tests (parallel matrix, ~10 min):
#   - test: 3 OS x 2 Python versions = 6 jobs
#
# Stage 4 - Agent Validation (~1 min):
#   - agent-sync: Verify agent name synchronization
#
# Stage 5 - Build (tags only, ~5 min):
#   - build: Create release packages
#
# Stage 6 - Release (tags only, ~2 min):
#   - release: Publish to GitHub Releases
#
# =============================================================================

name: CI/CD Pipeline

on:
  push:
    branches:
      - master
      - develop
      - installer
    tags:
      - 'v*'
  pull_request:
    branches:
      - master
      - develop

permissions:
  contents: write
  pull-requests: read

env:
  PYTHON_DEFAULT: '3.12'
  NODE_VERSION: '20'
  CACHE_VERSION: v3
  PYTHONIOENCODING: 'utf-8'
  PYTHONUTF8: '1'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ===========================================================================
  # STAGE 1: FAST CHECKS - Run in parallel on Linux (~1 minute total)
  # ===========================================================================

  commitlint:
    name: "Commit Messages"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache npm dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: npm-commitlint-${{ env.CACHE_VERSION }}
          restore-keys: npm-commitlint-

      - name: Install commitlint
        run: npm install -g @commitlint/cli@19.6.1 @commitlint/config-conventional@19.6.0

      - name: Validate commit messages
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            commitlint --from "${{ github.event.pull_request.base.sha }}" --to "${{ github.event.pull_request.head.sha }}" --verbose
          elif [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
            # Validate that 'before' commit exists in repository
            if git cat-file -e "${{ github.event.before }}" 2>/dev/null; then
              commitlint --from "${{ github.event.before }}" --to "${{ github.sha }}" --verbose
            else
              echo "::warning::Commit ${{ github.event.before }} not found (likely due to force push/amend). Validating HEAD commit only."
              git log -1 --format=%B | commitlint --verbose
            fi
          else
            git log -1 --format=%B | commitlint --verbose
          fi

  code-quality:
    name: "Code Quality (Ruff)"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Install ruff
        run: pip install ruff

      - name: Ruff lint
        run: ruff check scripts/ tools/ tests/ --exit-non-zero-on-fix

      - name: Ruff format check
        run: ruff format --check --diff scripts/ tools/ tests/

  file-quality:
    name: "File Quality"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Install PyYAML
        run: pip install pyyaml

      - name: Check trailing whitespace
        run: |
          if git ls-files | xargs grep -l '[[:blank:]]$' 2>/dev/null | grep -v -E '^(dist/|\.git/)'; then
            echo "::error::Files with trailing whitespace found"
            exit 1
          fi
          echo "::notice::No trailing whitespace found"

      - name: Check end of file newlines
        run: |
          failed=0
          for file in $(git ls-files | grep -v -E '^(dist/|\.git/)' | head -200); do
            if [ -f "$file" ] && [ -s "$file" ]; then
              if [ "$(tail -c 1 "$file" | wc -l)" -eq 0 ]; then
                echo "::error file=$file::Missing newline at end of file"
                failed=1
              fi
            fi
          done
          [ $failed -eq 0 ] && echo "::notice::All files have proper end-of-file newlines"
          exit $failed

      - name: Check YAML syntax
        run: |
          python3 << 'EOF'
          import yaml
          import sys
          from pathlib import Path

          errors = []
          for pattern in ['*.yaml', '*.yml']:
              for yaml_file in Path('.').rglob(pattern):
                  if '.git' in str(yaml_file) or 'dist' in str(yaml_file):
                      continue
                  try:
                      with open(yaml_file) as f:
                          yaml.safe_load(f)
                  except yaml.YAMLError as e:
                      errors.append(f'{yaml_file}: {e}')

          if errors:
              for e in errors:
                  print(f'::error::{e}')
              sys.exit(1)
          print('::notice::All YAML files have valid syntax')
          EOF

      - name: Check JSON syntax
        run: |
          python3 << 'EOF'
          import json
          import sys
          from pathlib import Path

          errors = []
          for json_file in Path('.').rglob('*.json'):
              if '.git' in str(json_file) or 'dist' in str(json_file) or 'node_modules' in str(json_file):
                  continue
              try:
                  with open(json_file) as f:
                      json.load(f)
              except json.JSONDecodeError as e:
                  errors.append(f'{json_file}: {e}')

          if errors:
              for e in errors:
                  print(f'::error::{e}')
              sys.exit(1)
          print('::notice::All JSON files have valid syntax')
          EOF

  security-checks:
    name: "Security Checks"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Check for merge conflict markers
        run: |
          if git ls-files | xargs grep -l -E '^(<<<<<<<|=======|>>>>>>>)' 2>/dev/null; then
            echo "::error::Merge conflict markers found in repository"
            exit 1
          fi
          echo "::notice::No merge conflict markers found"

      - name: Detect private keys
        run: |
          if git ls-files | xargs grep -l -E '-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----' 2>/dev/null; then
            echo "::error::Private key detected in repository"
            exit 1
          fi
          echo "::notice::No private keys detected"

      - name: Prevent shell scripts
        run: python3 scripts/hooks/prevent_shell_scripts.py

  # ===========================================================================
  # STAGE 2: FRAMEWORK VALIDATION - Depends on Stage 1
  # ===========================================================================

  framework-validation:
    name: "Framework Validation"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [commitlint, code-quality, file-quality, security-checks]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Install dependencies
        run: pip install pyyaml packaging

      - name: Validate framework-catalog.yaml
        run: |
          python3 << 'EOF'
          import yaml
          import sys
          import re

          with open('nWave/framework-catalog.yaml', 'r') as f:
              catalog = yaml.safe_load(f)

          required_fields = ['name', 'version', 'description', 'agents', 'commands']
          missing = [f for f in required_fields if f not in catalog]

          if missing:
              print(f'::error::Missing required fields in framework-catalog.yaml: {missing}')
              sys.exit(1)

          version = catalog['version']
          if not re.match(r'^\d+\.\d+\.\d+$', version):
              print(f'::error::Invalid version format: {version}')
              sys.exit(1)

          print(f'::notice::framework-catalog.yaml validation passed (version: {version})')
          EOF

      - name: Validate documentation version
        run: python3 scripts/hooks/validate_docs.py

      - name: Check documentation freshness
        run: python3 scripts/hooks/check_documentation_freshness.py

      - name: Detect file conflicts
        run: python3 scripts/hooks/detect_conflicts.py

  # ===========================================================================
  # STAGE 3: CROSS-PLATFORM TESTS - Depends on Framework Validation
  # ===========================================================================

  test:
    name: "Test - Py${{ matrix.python-version }} / ${{ matrix.os }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    needs: [framework-validation]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: ['3.11', '3.12']

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Configure Windows console for UTF-8
        if: runner.os == 'Windows'
        run: |
          chcp 65001
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        shell: pwsh

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/Library/Caches/pip
            ~\AppData\Local\pip\Cache
          key: ${{ runner.os }}-pip-${{ env.CACHE_VERSION }}-${{ matrix.python-version }}-${{ hashFiles('Pipfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ env.CACHE_VERSION }}-${{ matrix.python-version }}-
            ${{ runner.os }}-pip-${{ env.CACHE_VERSION }}-

      - name: Install pipenv and dependencies
        run: |
          python3 -m pip install --upgrade pip setuptools wheel pipenv
          pipenv install --dev --deploy --ignore-pipfile || pipenv install --dev
        shell: bash

      - name: Install commit-msg hook
        run: |
          python3 << 'EOF'
          import shutil
          from pathlib import Path
          import platform
          import stat

          src = Path('scripts/hooks/commit-msg')
          dest = Path('.git/hooks/commit-msg')
          shutil.copy(src, dest)

          if platform.system() != 'Windows':
              dest.chmod(dest.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

          print('Installed commit-msg hook')
          EOF
        shell: bash

      - name: Run pytest test suite
        run: |
          pipenv run pytest tests/ \
            --verbose \
            --tb=short \
            --cov=. \
            --cov-report=term-missing \
            --cov-report=xml \
            --cov-report=html \
            --junitxml=test-results-${{ matrix.os }}-py${{ matrix.python-version }}.xml
        shell: bash

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.os }}-py${{ matrix.python-version }}
          path: test-results-*.xml
          retention-days: 14

      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.os }}-py${{ matrix.python-version }}
          path: |
            coverage.xml
            htmlcov/
          retention-days: 14

      - name: Test Summary
        if: success()
        run: |
          echo "## Test Summary - Python ${{ matrix.python-version }} on ${{ matrix.os }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All tests passed" >> $GITHUB_STEP_SUMMARY
        shell: bash

  # ===========================================================================
  # STAGE 4: AGENT VALIDATION - Depends on Tests
  # ===========================================================================

  agent-sync:
    name: "Agent Sync Validation"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [test]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Install pipenv and dependencies
        run: |
          python3 -m pip install --upgrade pip pipenv
          pipenv install --dev --deploy --ignore-pipfile || pipenv install --dev

      - name: Verify agent name synchronization
        run: pipenv run python3 scripts/framework/sync_agent_names.py --verify

  # ===========================================================================
  # STAGE 5: BUILD - Only on Version Tags
  # ===========================================================================

  build:
    name: "Build Distribution"
    needs: [agent-sync]
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: Install build dependencies
        run: |
          python3 -m pip install --upgrade pip setuptools wheel pipenv
          pipenv install --dev

      - name: Extract version from tag
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT

      - name: Verify version consistency
        run: |
          TAG_VERSION="${{ steps.get_version.outputs.VERSION }}"
          CATALOG_VERSION=$(pipenv run python3 -c "import yaml; print(yaml.safe_load(open('nWave/framework-catalog.yaml'))['version'])")

          if [ "$TAG_VERSION" != "$CATALOG_VERSION" ]; then
            echo "::error::Version mismatch - tag: ${TAG_VERSION}, catalog: ${CATALOG_VERSION}"
            exit 1
          fi

      - name: Build IDE bundle
        run: |
          PYTHONPATH=tools pipenv run python3 tools/core/build_ide_bundle.py \
            --source-dir nWave \
            --output-dir dist/ide \
            --clean \
            --verbose

      - name: Create release packages
        run: |
          pipenv run python3 tools/create_release_packages.py \
            --version ${{ steps.get_version.outputs.VERSION }} \
            --output-dir dist/releases

      - name: Generate checksums
        run: |
          cd dist/releases
          sha256sum * > SHA256SUMS.txt
          cat SHA256SUMS.txt

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-packages
          path: dist/releases/*
          retention-days: 90

  # ===========================================================================
  # STAGE 6: RELEASE - Only on Version Tags
  # ===========================================================================

  release:
    name: "GitHub Release"
    needs: [build]
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: release-packages
          path: dist/releases

      - name: Extract version
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT

      - name: Generate release notes
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          RELEASE_DATE=$(date +%Y-%m-%d)

          cat > dist/releases/RELEASE_NOTES.md << EOF
          # nWave Framework v${VERSION}

          ## Release Information

          - **Version**: ${VERSION}
          - **Release Date**: ${RELEASE_DATE}
          - **Methodology**: DISCUSS > DESIGN > DISTILL > DEVELOP > DELIVER

          ## Installation

          \`\`\`bash
          curl -O https://github.com/${{ github.repository }}/releases/download/v${VERSION}/install-nwave-claude-code.py
          python install-nwave-claude-code.py
          \`\`\`

          ## Quality Assurance

          This release has passed all quality gates:
          - Conventional commit validation
          - Ruff lint and format checks
          - YAML/JSON syntax validation
          - Framework catalog validation
          - Documentation validation
          - Cross-platform tests (Linux, Windows, macOS)
          - Multi-Python version tests (3.11, 3.12)
          - Agent synchronization verification
          EOF

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          name: nWave Framework v${{ steps.get_version.outputs.VERSION }}
          body_path: dist/releases/RELEASE_NOTES.md
          draft: false
          prerelease: ${{ contains(github.ref, '-beta') || contains(github.ref, '-rc') || contains(github.ref, '-alpha') }}
          files: |
            dist/releases/*.tar.gz
            dist/releases/*.py
            dist/releases/SHA256SUMS.txt
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ===========================================================================
  # NOTIFICATION: SLACK ALERTS - Always run on failure
  # ===========================================================================

  notify-slack:
    name: "Slack Notification"
    runs-on: ubuntu-latest
    timeout-minutes: 2
    # Run ONLY if any previous job failed AND on master/develop/installer branches
    if: |
      failure() &&
      (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/installer')
    needs: [commitlint, code-quality, file-quality, security-checks, framework-validation, test, agent-sync, build, release]

    steps:
      - name: Send Slack notification
        uses: slackapi/slack-github-action@v2.0.0
        with:
          # REQUIRED: Configure SLACK_WEBHOOK_URL secret in repository settings
          # Navigate to: Settings > Secrets and variables > Actions > New repository secret
          # Name: SLACK_WEBHOOK_URL
          # Value: Your Slack Incoming Webhook URL (https://hooks.slack.com/services/T.../B.../XXX)
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "üö® CI/CD Pipeline Failed",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Repository:*\n<https://github.com/${{ github.repository }}|${{ github.repository }}>"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n`${{ github.ref_name }}`"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Commit:*\n<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|`${{ github.sha }}`>"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Author:*\n${{ github.actor }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Workflow:*\n${{ github.workflow }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Event:*\n${{ github.event_name }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Commit Message:*\n${{ github.event.head_commit.message }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Logs",
                        "emoji": true
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
                      "style": "danger"
                    },
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Commit",
                        "emoji": true
                      },
                      "url": "https://github.com/${{ github.repository }}/commit/${{ github.sha }}"
                    }
                  ]
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "‚è∞ Workflow run #${{ github.run_number }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
