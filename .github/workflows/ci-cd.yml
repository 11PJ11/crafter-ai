# =============================================================================
# nWave Framework CI/CD Pipeline v2.1
# =============================================================================
#
# Architecture: Optimized parallel execution with intelligent grouping
#
# Stage 1 - Fast Checks (parallel, ~1 min):
#   - gitlint: Conventional commits validation (Python-based)
#   - code-quality: Ruff lint + format
#   - file-quality: Whitespace, EOF, YAML, JSON syntax
#   - security: Merge conflicts, private keys, shell prevention
#
# Stage 2 - Framework Validation (parallel, ~2 min):
#   - framework-validation: YAML schema, docs version, freshness, conflicts
#
# Stage 3 - Cross-Platform Tests (parallel matrix, ~10 min):
#   - test: 3 OS x 2 Python versions = 6 jobs
#
# Stage 4 - Agent Validation (~1 min):
#   - agent-sync: Verify agent name synchronization
#
# Stage 5 - Version Tag (master push only, ~1 min):
#   - version-tag: python-semantic-release calculates next semver, updates
#     pyproject.toml + framework-catalog.yaml, commits, tags, and pushes
#
# Stage 6 - Build (tags only, ~5 min):
#   - build: Create release packages
#
# Stage 7 - Release (tags only, ~2 min):
#   - release: Publish to GitHub Releases
#
# =============================================================================

name: CI/CD Pipeline

on:
  push:
    branches:
      - master
      - develop
      - installer
    tags:
      - 'v*'
  pull_request:
    branches:
      - master
      - develop

permissions:
  contents: write
  pull-requests: read

env:
  PYTHON_DEFAULT: '3.12'
  CACHE_VERSION: v3
  PYTHONIOENCODING: 'utf-8'
  PYTHONUTF8: '1'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ===========================================================================
  # STAGE 1: FAST CHECKS - Run in parallel on Linux (~1 minute total)
  # ===========================================================================

  commitlint:
    name: "üìù Commit Messages"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: üì¶ Install gitlint
        run: pip install gitlint

      - name: ‚úÖ Validate commit messages
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            gitlint --commits "${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }}"
          elif [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
            # Validate that 'before' commit exists in repository
            if git cat-file -e "${{ github.event.before }}" 2>/dev/null; then
              gitlint --commits "${{ github.event.before }}..${{ github.sha }}"
            else
              echo "::warning::Commit ${{ github.event.before }} not found (likely due to force push/amend). Validating HEAD commit only."
              gitlint
            fi
          else
            gitlint
          fi

  code-quality:
    name: "üîç Code Quality (Ruff)"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: üì¶ Install ruff
        run: pip install ruff

      - name: üßπ Ruff lint
        run: ruff check src/ scripts/ tools/ tests/ --exit-non-zero-on-fix

      - name: üé® Ruff format check
        run: ruff format --check --diff src/ scripts/ tools/ tests/

  file-quality:
    name: "üìÑ File Quality"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: üì¶ Install PyYAML
        run: pip install pyyaml

      - name: üîé Check trailing whitespace
        run: |
          if git ls-files | xargs grep -l '[[:blank:]]$' 2>/dev/null | grep -v -E '^(dist/|\.git/)'; then
            echo "::error::Files with trailing whitespace found"
            exit 1
          fi
          echo "::notice::No trailing whitespace found"

      - name: üîé Check end of file newlines
        run: |
          failed=0
          for file in $(git ls-files | grep -v -E '^(dist/|\.git/)' | head -200); do
            if [ -f "$file" ] && [ -s "$file" ]; then
              if [ "$(tail -c 1 "$file" | wc -l)" -eq 0 ]; then
                echo "::error file=$file::Missing newline at end of file"
                failed=1
              fi
            fi
          done
          [ $failed -eq 0 ] && echo "::notice::All files have proper end-of-file newlines"
          exit $failed

      - name: üîé Check YAML syntax
        run: |
          python3 << 'EOF'
          import yaml
          import sys
          from pathlib import Path

          errors = []
          for pattern in ['*.yaml', '*.yml']:
              for yaml_file in Path('.').rglob(pattern):
                  if '.git' in str(yaml_file) or 'dist' in str(yaml_file):
                      continue
                  try:
                      with open(yaml_file) as f:
                          yaml.safe_load(f)
                  except yaml.YAMLError as e:
                      errors.append(f'{yaml_file}: {e}')

          if errors:
              for e in errors:
                  print(f'::error::{e}')
              sys.exit(1)
          print('::notice::All YAML files have valid syntax')
          EOF

      - name: üîé Check JSON syntax
        run: |
          python3 << 'EOF'
          import json
          import sys
          from pathlib import Path

          errors = []
          for json_file in Path('.').rglob('*.json'):
              if '.git' in str(json_file) or 'dist' in str(json_file) or 'node_modules' in str(json_file):
                  continue
              try:
                  with open(json_file) as f:
                      json.load(f)
              except json.JSONDecodeError as e:
                  errors.append(f'{json_file}: {e}')

          if errors:
              for e in errors:
                  print(f'::error::{e}')
              sys.exit(1)
          print('::notice::All JSON files have valid syntax')
          EOF

  security-checks:
    name: "üîí Security Checks"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: üîé Check for merge conflict markers
        run: |
          if git ls-files | xargs grep -l -E '^(<<<<<<<|=======|>>>>>>>)' 2>/dev/null; then
            echo "::error::Merge conflict markers found in repository"
            exit 1
          fi
          echo "::notice::No merge conflict markers found"

      - name: üîë Detect private keys
        run: |
          if git ls-files | xargs grep -l -E '-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----' 2>/dev/null; then
            echo "::error::Private key detected in repository"
            exit 1
          fi
          echo "::notice::No private keys detected"

      - name: üõ°Ô∏è Prevent shell scripts
        run: python3 scripts/hooks/prevent_shell_scripts.py

  # ===========================================================================
  # STAGE 2: FRAMEWORK VALIDATION - Depends on Stage 1
  # ===========================================================================

  framework-validation:
    name: "üèóÔ∏è Framework Validation"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [commitlint, code-quality, file-quality, security-checks]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: üì¶ Install dependencies
        run: pip install pyyaml packaging

      - name: ‚úÖ Validate framework-catalog.yaml
        run: |
          python3 << 'EOF'
          import yaml
          import sys
          import re

          with open('nWave/framework-catalog.yaml', 'r') as f:
              catalog = yaml.safe_load(f)

          required_fields = ['name', 'version', 'description', 'agents', 'commands']
          missing = [f for f in required_fields if f not in catalog]

          if missing:
              print(f'::error::Missing required fields in framework-catalog.yaml: {missing}')
              sys.exit(1)

          version = catalog['version']
          if not re.match(r'^\d+\.\d+\.\d+$', version):
              print(f'::error::Invalid version format: {version}')
              sys.exit(1)

          print(f'::notice::framework-catalog.yaml validation passed (version: {version})')
          EOF

      - name: üìñ Validate documentation version
        run: python3 scripts/hooks/validate_docs.py

      - name: üïê Check documentation freshness
        run: python3 scripts/hooks/check_documentation_freshness.py

      - name: üí• Detect file conflicts
        run: python3 scripts/hooks/detect_conflicts.py

  # ===========================================================================
  # STAGE 3: CROSS-PLATFORM TESTS - Depends on Framework Validation
  # ===========================================================================

  test:
    name: "üß™ Test - Py${{ matrix.python-version }} / ${{ matrix.os }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    needs: [framework-validation]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: ['3.11', '3.12']

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: ü™ü Configure Windows console for UTF-8
        if: runner.os == 'Windows'
        run: |
          chcp 65001
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        shell: pwsh

      - name: üíæ Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/Library/Caches/pip
            ~\AppData\Local\pip\Cache
          key: ${{ runner.os }}-pip-${{ env.CACHE_VERSION }}-${{ matrix.python-version }}-${{ hashFiles('Pipfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ env.CACHE_VERSION }}-${{ matrix.python-version }}-
            ${{ runner.os }}-pip-${{ env.CACHE_VERSION }}-

      - name: üì¶ Install pipenv and dependencies
        run: |
          python3 -m pip install --upgrade pip setuptools wheel pipenv
          pipenv install --dev --deploy --ignore-pipfile || pipenv install --dev
        shell: bash

      - name: ü™ù Install commit-msg hook
        run: |
          python3 << 'EOF'
          import shutil
          from pathlib import Path
          import platform
          import stat

          src = Path('scripts/hooks/commit-msg')
          dest = Path('.git/hooks/commit-msg')
          shutil.copy(src, dest)

          if platform.system() != 'Windows':
              dest.chmod(dest.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

          print('Installed commit-msg hook')
          EOF
        shell: bash

      - name: üî® Build IDE bundle for integration tests
        run: |
          PYTHONPATH=tools pipenv run python3 tools/core/build_ide_bundle.py \
            --source-dir nWave \
            --output-dir dist/ide
        shell: bash

      - name: üß™ Run pytest test suite
        run: |
          pipenv run pytest tests/ \
            --verbose \
            --tb=short \
            --cov \
            --cov-report=term-missing \
            --cov-report=xml \
            --cov-report=html \
            --junitxml=test-results-${{ matrix.os }}-py${{ matrix.python-version }}.xml
        shell: bash

      - name: üì§ Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.os }}-py${{ matrix.python-version }}
          path: test-results-*.xml
          retention-days: 14

      - name: üì§ Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.os }}-py${{ matrix.python-version }}
          path: |
            coverage.xml
            htmlcov/
          retention-days: 14

      - name: üìä Test Summary
        if: success()
        run: |
          echo "## Test Summary - Python ${{ matrix.python-version }} on ${{ matrix.os }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All tests passed" >> $GITHUB_STEP_SUMMARY
        shell: bash

  # ===========================================================================
  # STAGE 4: AGENT VALIDATION - Depends on Tests
  # ===========================================================================

  agent-sync:
    name: "ü§ñ Agent Sync Validation"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [test]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: üì¶ Install pipenv and dependencies
        run: |
          python3 -m pip install --upgrade pip pipenv
          pipenv install --dev --deploy --ignore-pipfile || pipenv install --dev

      - name: ‚úÖ Verify agent name synchronization
        run: pipenv run python3 scripts/framework/sync_agent_names.py --verify

  # ===========================================================================
  # STAGE 5: VERSION TAG - Auto-tag on master push
  # ===========================================================================

  version-tag:
    name: "üè∑Ô∏è Version Tag"
    needs: [agent-sync]
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_TOKEN }}

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: üì¶ Install python-semantic-release
        run: pip install python-semantic-release

      - name: üè∑Ô∏è Calculate version and create tag
        run: semantic-release version
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: üìä Version Summary
        if: success()
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          echo "## üè∑Ô∏è Semantic Release" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Latest tag**: \`$LATEST_TAG\`" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # STAGE 6: BUILD - Only on Version Tags
  # ===========================================================================

  build:
    name: "üì¶ Build Distribution"
    needs: [agent-sync]
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - name: üì¶ Install build dependencies
        run: |
          python3 -m pip install --upgrade pip setuptools wheel pipenv
          pipenv install --dev

      - name: üè∑Ô∏è Extract version from tag
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT

      - name: ‚úÖ Verify version consistency
        run: |
          TAG_VERSION="${{ steps.get_version.outputs.VERSION }}"
          CATALOG_VERSION=$(pipenv run python3 -c "import yaml; print(yaml.safe_load(open('nWave/framework-catalog.yaml'))['version'])")

          if [ "$TAG_VERSION" != "$CATALOG_VERSION" ]; then
            echo "::error::Version mismatch - tag: ${TAG_VERSION}, catalog: ${CATALOG_VERSION}"
            exit 1
          fi

      - name: üî® Build IDE bundle
        run: |
          PYTHONPATH=tools pipenv run python3 tools/core/build_ide_bundle.py \
            --source-dir nWave \
            --output-dir dist/ide \
            --clean \
            --verbose

      - name: üì¶ Create release packages
        run: |
          pipenv run python3 tools/create_release_packages.py \
            --version ${{ steps.get_version.outputs.VERSION }} \
            --output-dir dist/releases

      - name: üîê Generate checksums
        run: |
          cd dist/releases
          sha256sum * > SHA256SUMS.txt
          cat SHA256SUMS.txt

      - name: üì§ Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-packages
          path: dist/releases/*
          retention-days: 90

  # ===========================================================================
  # STAGE 7: RELEASE - Only on Version Tags
  # ===========================================================================

  release:
    name: "üöÄ GitHub Release"
    needs: [build]
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_DEFAULT }}

      - uses: actions/download-artifact@v4
        with:
          name: release-packages
          path: dist/releases

      - name: üè∑Ô∏è Extract version
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT

      - name: üìã Generate changelog from conventional commits
        run: |
          python3 << 'PYEOF'
          import subprocess
          import re
          import os
          from datetime import datetime, timezone

          version = os.environ.get("VERSION", "0.0.0")
          repo = os.environ.get("GITHUB_REPOSITORY", "")
          release_date = datetime.now(timezone.utc).strftime("%Y-%m-%d")

          # Find previous tag
          try:
              prev_tag = subprocess.check_output(
                  ["git", "describe", "--tags", "--abbrev=0", "HEAD^"],
                  text=True, stderr=subprocess.DEVNULL
              ).strip()
          except subprocess.CalledProcessError:
              prev_tag = ""

          # Build git log command with record separator
          record_end = "<<--EOR-->>"
          fmt = f"%s%x00%b%x00%h{record_end}"
          cmd = ["git", "log", "--no-merges", f"--pretty=format:{fmt}"]
          if prev_tag:
              cmd.insert(2, f"{prev_tag}..HEAD")

          try:
              raw = subprocess.check_output(cmd, text=True)
          except subprocess.CalledProcessError:
              raw = ""

          # Parse commits into categories
          breaking = []
          features = []
          fixes = []
          other = []

          conventional_re = re.compile(
              r"^(?P<type>[a-z]+)(?:\((?P<scope>[^)]*)\))?(?P<bang>!)?:\s*(?P<desc>.+)$"
          )

          for record in raw.split(record_end):
              record = record.strip()
              if not record:
                  continue

              parts = record.split("\x00")
              if len(parts) < 3:
                  continue

              subject = parts[0].strip()
              body = parts[1].strip()
              commit_hash = parts[2].strip()

              if not subject or not commit_hash:
                  continue

              m = conventional_re.match(subject)
              is_breaking = False

              if m and m.group("bang"):
                  is_breaking = True
              if "BREAKING CHANGE:" in body or "BREAKING-CHANGE:" in body:
                  is_breaking = True

              line = f"- {subject} (`{commit_hash}`)"

              if is_breaking:
                  breaking.append(line)
              elif m:
                  ctype = m.group("type")
                  if ctype == "feat":
                      features.append(line)
                  elif ctype == "fix":
                      fixes.append(line)
                  else:
                      other.append(line)
              else:
                  other.append(line)

          # Build changelog markdown
          sections = []
          sections.append(f"# nWave Framework v{version}\n")
          sections.append(f"**Release Date**: {release_date}\n")

          if prev_tag:
              compare_url = f"https://github.com/{repo}/compare/{prev_tag}...v{version}"
              sections.append(f"**Full Changelog**: [{prev_tag}...v{version}]({compare_url})\n")

          if breaking:
              sections.append("## Breaking Changes\n")
              sections.append("\n".join(breaking) + "\n")

          if features:
              sections.append("## Features\n")
              sections.append("\n".join(features) + "\n")

          if fixes:
              sections.append("## Bug Fixes\n")
              sections.append("\n".join(fixes) + "\n")

          if other:
              sections.append("## Other Changes\n")
              sections.append("\n".join(other) + "\n")

          if not (breaking or features or fixes or other):
              sections.append("No conventional commits found in this release.\n")

          sections.append("## Installation\n")
          sections.append(
              f"```bash\n"
              f"curl -O https://github.com/{repo}/releases/download/"
              f"v{version}/install-nwave-claude-code.py\n"
              f"python install-nwave-claude-code.py\n"
              f"```\n"
          )

          changelog = "\n".join(sections)

          os.makedirs("dist/releases", exist_ok=True)
          with open("dist/releases/RELEASE_NOTES.md", "w") as f:
              f.write(changelog)

          print(changelog)
          PYEOF
        env:
          VERSION: ${{ steps.get_version.outputs.VERSION }}

      - name: üöÄ Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          name: nWave Framework v${{ steps.get_version.outputs.VERSION }}
          body_path: dist/releases/RELEASE_NOTES.md
          draft: false
          prerelease: ${{ contains(github.ref, '-beta') || contains(github.ref, '-rc') || contains(github.ref, '-alpha') }}
          files: |
            dist/releases/*.tar.gz
            dist/releases/*.py
            dist/releases/SHA256SUMS.txt
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ===========================================================================
  # NOTIFICATION: SLACK ALERTS - RED on failure, GREEN on recovery
  # ===========================================================================

  notify-slack:
    name: "üîî Slack Notification"
    runs-on: ubuntu-latest
    timeout-minutes: 3
    # Run on BOTH failure AND success (to detect RED‚ÜíGREEN transitions)
    # Now triggers on ALL branches - @mentions ensure no spam (each dev gets notified for their branches only)
    if: |
      always() &&
      !cancelled()
    needs: [commitlint, code-quality, file-quality, security-checks, framework-validation, test, agent-sync, version-tag, build, release]

    steps:
      - name: üì• Checkout (for state tracking script)
        uses: actions/checkout@v4

      - name: üîç Determine current status
        id: current-status
        run: |
          # Check if any job failed
          NEEDS_CONTEXT='${{ toJson(needs) }}'
          echo "Needs context: $NEEDS_CONTEXT"

          if echo "$NEEDS_CONTEXT" | jq -e '.[] | select(.result == "failure")' > /dev/null; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "Current run: FAILURE"
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "Current run: SUCCESS"
          fi

      - name: üíæ Load previous run state
        id: previous-state
        uses: actions/cache/restore@v4
        with:
          path: .pipeline-state
          key: pipeline-state-${{ github.ref }}-never-match
          restore-keys: |
            pipeline-state-${{ github.ref }}-

      - name: üö¶ Determine notification type
        id: notification-type
        run: |
          CURRENT="${{ steps.current-status.outputs.status }}"

          # Load previous status
          if [ -f .pipeline-state/status.txt ]; then
            PREVIOUS=$(cat .pipeline-state/status.txt)
            echo "Previous run status: $PREVIOUS"
          else
            PREVIOUS="unknown"
            echo "No previous run status found"
          fi

          echo "Current: $CURRENT, Previous: $PREVIOUS"

          # Determine notification type based on state transition
          if [[ "$CURRENT" == "failure" ]]; then
            echo "type=failure" >> $GITHUB_OUTPUT
            echo "should_notify=true" >> $GITHUB_OUTPUT
            echo "Will send RED notification"
          elif [[ "$CURRENT" == "success" && "$PREVIOUS" == "failure" ]]; then
            echo "type=back_to_green" >> $GITHUB_OUTPUT
            echo "should_notify=true" >> $GITHUB_OUTPUT
            echo "Will send GREEN notification (recovery)"
          else
            echo "type=none" >> $GITHUB_OUTPUT
            echo "should_notify=false" >> $GITHUB_OUTPUT
            echo "No notification needed (already green)"
          fi

      - name: ‚ùå Parse failed jobs
        id: failed-jobs
        if: steps.current-status.outputs.status == 'failure'
        run: |
          NEEDS_CONTEXT='${{ toJson(needs) }}'

          # Extract failed job names
          FAILED_JOBS=$(echo "$NEEDS_CONTEXT" | jq -r '
            to_entries
            | map(select(.value.result == "failure"))
            | map("‚Ä¢ " + .key)
            | join("\n")
          ')

          if [ -z "$FAILED_JOBS" ]; then
            FAILED_JOBS="‚Ä¢ Multiple jobs failed"
          fi

          echo "Failed jobs:"
          echo "$FAILED_JOBS"

          # Store for Slack payload (escape for JSON)
          echo "jobs<<EOF" >> $GITHUB_OUTPUT
          echo "$FAILED_JOBS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üìä Load failure metadata for GREEN notification
        id: failure-metadata
        if: steps.notification-type.outputs.type == 'back_to_green'
        run: |
          if [ -f .pipeline-state/failure-time.txt ]; then
            FAILURE_TIME=$(cat .pipeline-state/failure-time.txt)
            echo "failure_time=$FAILURE_TIME" >> $GITHUB_OUTPUT

            # Calculate time since failure
            CURRENT_TIME=$(date +%s)
            TIME_DIFF=$((CURRENT_TIME - FAILURE_TIME))

            # Format time difference (smart: 5 min, 18 minutes, 2h 34m, 1d 3h)
            if [ $TIME_DIFF -lt 60 ]; then
              TIME_DISPLAY="${TIME_DIFF} sec"
            elif [ $TIME_DIFF -lt 3600 ]; then
              MINUTES=$((TIME_DIFF / 60))
              if [ $MINUTES -eq 1 ]; then
                TIME_DISPLAY="1 minute"
              else
                TIME_DISPLAY="${MINUTES} minutes"
              fi
            elif [ $TIME_DIFF -lt 86400 ]; then
              HOURS=$((TIME_DIFF / 3600))
              MINUTES=$(((TIME_DIFF % 3600) / 60))
              TIME_DISPLAY="${HOURS}h ${MINUTES}m"
            else
              DAYS=$((TIME_DIFF / 86400))
              HOURS=$(((TIME_DIFF % 86400) / 3600))
              TIME_DISPLAY="${DAYS}d ${HOURS}h"
            fi

            echo "time_since_failure=$TIME_DISPLAY" >> $GITHUB_OUTPUT
          else
            echo "time_since_failure=unknown" >> $GITHUB_OUTPUT
          fi

          # Load failed jobs from previous RED notification
          if [ -f .pipeline-state/failed-jobs.txt ]; then
            FAILED_JOBS=$(cat .pipeline-state/failed-jobs.txt | sed 's/^‚Ä¢ /‚Ä¢ /; s/$/ ‚úÖ now passing/')
            echo "previously_failed<<EOF" >> $GITHUB_OUTPUT
            echo "$FAILED_JOBS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "previously_failed=‚Ä¢ All jobs ‚úÖ now passing" >> $GITHUB_OUTPUT
          fi

      - name: üë§ Map git author to Slack user ID
        id: slack-author
        run: |
          GIT_AUTHOR="${{ github.actor }}"

          # Author mapping (git username ‚Üí Slack user ID)
          case "$GIT_AUTHOR" in
            "undeadgrishnackh")
              SLACK_USER="<@U05HX4GEVGR>"  # michele.brissoni@brix.consulting
              ;;
            "11PJ11")
              SLACK_USER="<@U07G5FJBN85>"  # alessandro.digioia@brix.consulting
              ;;
            *)
              SLACK_USER="$GIT_AUTHOR"  # Fallback to plaintext
              echo "::warning::Author mapping missing for '$GIT_AUTHOR'"
              ;;
          esac

          echo "author=$SLACK_USER" >> $GITHUB_OUTPUT
          echo "Slack author: $SLACK_USER"

      - name: ‚úÇÔ∏è Truncate commit message
        id: commit-msg
        run: |
          MSG="${{ github.event.head_commit.message }}"
          FIRST_LINE=$(echo "$MSG" | head -1)

          if [ ${#FIRST_LINE} -gt 100 ]; then
            TRUNCATED="${FIRST_LINE:0:97}..."
          else
            TRUNCATED="$FIRST_LINE"
          fi

          echo "message=$TRUNCATED" >> $GITHUB_OUTPUT

      - name: üïê Get current timestamp
        id: timestamp
        run: |
          CURRENT_TIMESTAMP=$(date +%s)
          echo "unix=$CURRENT_TIMESTAMP" >> $GITHUB_OUTPUT
          echo "Current Unix timestamp: $CURRENT_TIMESTAMP"

      - name: üî¥ Send RED notification (failure)
        if: steps.notification-type.outputs.type == 'failure'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook-type: incoming-webhook
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "üî¥ Pipeline Failed: ${{ github.workflow }}",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n${{ github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Author:*\n${{ steps.slack-author.outputs.author }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üìù *${{ steps.commit-msg.outputs.message }}*\nCommit: `${{ github.sha }}`"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*‚ùå Failed Jobs:*\n${{ steps.failed-jobs.outputs.jobs }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Run"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
                      "style": "danger"
                    },
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Commit"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
                    }
                  ]
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "‚è±Ô∏è Failed at: <!date^${{ steps.timestamp.outputs.unix }}^{date_short_pretty} at {time}|timestamp>"
                    }
                  ]
                }
              ]
            }

      - name: üü¢ Send GREEN notification (recovery)
        if: steps.notification-type.outputs.type == 'back_to_green'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook-type: incoming-webhook
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "‚úÖ Pipeline Recovered: ${{ github.workflow }}",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n${{ github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Fixed by:*\n${{ steps.slack-author.outputs.author }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üìù *${{ steps.commit-msg.outputs.message }}*\nCommit: `${{ github.sha }}`"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üéâ *Back to green* after ${{ steps.failure-metadata.outputs.time_since_failure }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Previously failed:*\n${{ steps.failure-metadata.outputs.previously_failed }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Run"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
                      "style": "primary"
                    },
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Commit"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
                    }
                  ]
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "üü¢ All systems healthy"
                    }
                  ]
                }
              ]
            }

      - name: üíæ Save current state for next run
        if: always()
        run: |
          mkdir -p .pipeline-state
          echo "${{ steps.current-status.outputs.status }}" > .pipeline-state/status.txt

          # If failure, save metadata for future GREEN notification
          if [[ "${{ steps.current-status.outputs.status }}" == "failure" ]]; then
            date +%s > .pipeline-state/failure-time.txt
            echo "${{ steps.failed-jobs.outputs.jobs }}" > .pipeline-state/failed-jobs.txt
          fi

          # If success, clear failure metadata
          if [[ "${{ steps.current-status.outputs.status }}" == "success" ]]; then
            rm -f .pipeline-state/failure-time.txt
            rm -f .pipeline-state/failed-jobs.txt
          fi

      - name: üíæ Cache current state
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .pipeline-state
          key: pipeline-state-${{ github.ref }}-${{ github.run_id }}
