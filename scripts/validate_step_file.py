#!/usr/bin/env python3
"""
nWave Step File Validator

Validates that step files generated by /nw:split have the correct structure,
including the mandatory phase_execution_log with all 14 TDD phases.

Usage:
    python validate_step_file.py <step_file.json> [<step_file2.json> ...]
    python validate_step_file.py --all <steps_directory>

Exit codes:
    0 - All validations passed
    1 - Validation failed
    2 - Usage error

This script should be run after /nw:split to verify step file generation.
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Tuple

# Version - Must match nWave/framework-catalog.yaml version
__version__ = "1.2.20"

# Required TDD phases (14 total)
REQUIRED_PHASES = [
    "PREPARE",
    "RED_ACCEPTANCE",
    "RED_UNIT",
    "GREEN_UNIT",
    "CHECK_ACCEPTANCE",
    "GREEN_ACCEPTANCE",
    "REVIEW",
    "REFACTOR_L1",
    "REFACTOR_L2",
    "REFACTOR_L3",
    "REFACTOR_L4",
    "POST_REFACTOR_REVIEW",
    "FINAL_VALIDATE",
    "COMMIT",
]

# Required top-level fields in step files
REQUIRED_FIELDS = [
    "task_id",
    "project_id",
    "execution_agent",
    "self_contained_context",
    "task_specification",
    "dependencies",
    "state",
]

# Required fields in tdd_cycle
REQUIRED_TDD_FIELDS = [
    "acceptance_test",
    "phase_execution_log",
]


def validate_phase_execution_log(
    phase_log: List[Dict[str, Any]], file_path: str
) -> List[str]:
    """Validate phase_execution_log has all 14 phases properly structured."""
    issues: List[str] = []

    if not phase_log:
        issues.append("phase_execution_log is empty or missing")
        return issues

    if len(phase_log) != 14:
        issues.append(f"phase_execution_log has {len(phase_log)} phases, expected 14")

    # Build lookup by phase name
    phase_lookup = {p.get("phase_name"): p for p in phase_log}

    for i, expected_phase in enumerate(REQUIRED_PHASES):
        entry = phase_lookup.get(expected_phase)

        if not entry:
            issues.append(f"Missing phase: {expected_phase}")
            continue

        # Verify phase_index
        phase_index = entry.get("phase_index")
        if phase_index != i:
            issues.append(
                f"{expected_phase}: phase_index is {phase_index}, expected {i}"
            )

        # Verify status is valid
        status = entry.get("status")
        valid_statuses = ["NOT_EXECUTED", "IN_PROGRESS", "EXECUTED", "SKIPPED"]
        if status not in valid_statuses:
            issues.append(f"{expected_phase}: invalid status '{status}'")

        # For newly generated files, status should be NOT_EXECUTED or SKIPPED
        # (SKIPPED only for research/infrastructure steps)

    return issues


def validate_step_file(file_path: Path) -> Tuple[bool, List[str]]:
    """Validate a single step file.

    Args:
        file_path: Path to the step JSON file

    Returns:
        Tuple of (is_valid, list of issues)
    """
    issues: List[str] = []

    # Check file exists
    if not file_path.exists():
        return False, [f"File not found: {file_path}"]

    # Parse JSON
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        return False, [f"Invalid JSON: {e}"]
    except Exception as e:
        return False, [f"Cannot read file: {e}"]

    # Check required top-level fields
    for field in REQUIRED_FIELDS:
        if field not in data:
            issues.append(f"Missing required field: {field}")

    # REJECT OLD/WRONG FORMAT PATTERNS
    if "step_id" in data:
        issues.append(
            "WRONG FORMAT: Found 'step_id' - use 'task_id' instead. "
            "This is an obsolete format that must be regenerated."
        )
    if "phase_id" in data:
        issues.append(
            "WRONG FORMAT: Found 'phase_id' - this field should not exist. "
            "Each step contains ALL 14 phases, not a single phase."
        )
    if "tdd_phase" in data and "tdd_cycle" not in data:
        issues.append(
            "WRONG FORMAT: Found 'tdd_phase' at top level without 'tdd_cycle'. "
            "Phases must be in tdd_cycle.phase_execution_log array."
        )

    # Check tdd_cycle exists
    tdd_cycle = data.get("tdd_cycle")
    if not tdd_cycle:
        issues.append("Missing tdd_cycle section (CRITICAL - phases cannot be tracked)")
        return False, issues

    # Check required tdd_cycle fields
    for field in REQUIRED_TDD_FIELDS:
        if field not in tdd_cycle:
            issues.append(f"Missing tdd_cycle.{field}")

    # Validate phase_execution_log
    phase_log = tdd_cycle.get("phase_execution_log", [])
    phase_issues = validate_phase_execution_log(phase_log, str(file_path))
    issues.extend(phase_issues)

    # Check quality_gates exists
    if "quality_gates" not in data:
        issues.append("Missing quality_gates section")

    # Check phase_validation_rules exists
    if "phase_validation_rules" not in data:
        issues.append("Missing phase_validation_rules section")

    return len(issues) == 0, issues


def validate_directory(dir_path: Path) -> Tuple[bool, Dict[str, List[str]]]:
    """Validate all step files in a directory.

    Args:
        dir_path: Path to the steps directory

    Returns:
        Tuple of (all_valid, dict of {filename: issues})
    """
    results: Dict[str, List[str]] = {}
    all_valid = True

    # Find all JSON files
    step_files = list(dir_path.glob("*.json"))

    if not step_files:
        return False, {"directory": [f"No JSON files found in {dir_path}"]}

    for step_file in sorted(step_files):
        is_valid, issues = validate_step_file(step_file)
        if not is_valid:
            all_valid = False
            results[step_file.name] = issues

    return all_valid, results


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Validate nWave step files generated by /nw:split",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Validate a single step file
    python validate_step_file.py docs/feature/auth/steps/01-01.json

    # Validate multiple step files
    python validate_step_file.py steps/01-01.json steps/01-02.json

    # Validate all step files in a directory
    python validate_step_file.py --all docs/feature/auth/steps/
        """,
    )

    parser.add_argument(
        "files",
        nargs="*",
        help="Step file(s) to validate",
    )

    parser.add_argument(
        "--all",
        dest="directory",
        metavar="DIR",
        help="Validate all step files in directory",
    )

    parser.add_argument(
        "--quiet",
        "-q",
        action="store_true",
        help="Only show errors, not success messages",
    )

    args = parser.parse_args()

    if not args.files and not args.directory:
        parser.print_help()
        return 2

    all_valid = True

    # Validate directory
    if args.directory:
        dir_path = Path(args.directory)
        if not dir_path.is_dir():
            print(f"Error: {dir_path} is not a directory")
            return 2

        is_valid, results = validate_directory(dir_path)
        all_valid = all_valid and is_valid

        if results:
            for filename, issues in results.items():
                print(f"\n{filename}:")
                for issue in issues:
                    print(f"   {issue}")
        elif not args.quiet:
            step_count = len(list(dir_path.glob("*.json")))
            print(f"All {step_count} step files in {dir_path} are valid")

    # Validate individual files
    for file_arg in args.files:
        file_path = Path(file_arg)
        is_valid, issues = validate_step_file(file_path)

        if not is_valid:
            all_valid = False
            print(f"\n{file_path}:")
            for issue in issues:
                print(f"   {issue}")
        elif not args.quiet:
            print(f"{file_path}: Valid")

    if all_valid:
        if not args.quiet:
            print("\n All step files validated successfully")
        return 0
    else:
        print("\n Step file validation FAILED")
        print("   Ensure /nw:split properly embeds tdd_cycle with phase_execution_log")
        return 1


if __name__ == "__main__":
    sys.exit(main())
