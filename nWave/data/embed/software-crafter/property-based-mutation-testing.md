# Property-Based Testing and Mutation Testing Knowledge

> **DEFERRED TO PHASE 2.25**: Mutation testing runs ONCE per feature as a final quality gate at orchestrator Phase 2.25 (after all steps complete). Do NOT run mutation testing during the inner TDD loop. This knowledge is reference material for Phase 2.25 execution only.

## Property-Based Testing (PBT)
Instead of examples ("given X, expect Y"), write properties ("for all valid inputs, condition Z holds").
Framework generates hundreds/thousands of inputs checking property. Dramatically expands test coverage.

## Property Patterns
1. Invariants: "for all inputs, condition holds" (sorted list is ordered, balance >= 0)
2. Roundtrip: "encode then decode = original" (serialize/deserialize, compress/decompress)
3. Oracle: "compare against reference implementation" (optimized vs correct-but-slow)
4. Metamorphic: "different operations, same result" (add(a,b)==add(b,a), filter can't increase size)

## Shrinking (killer feature)
When property fails, framework auto-finds minimal failing input. Dramatically accelerates debugging.
Algorithm: find failing input -> try simpler variants -> if still fails, use as new candidate -> repeat.

## PBT Tools by Language
Python: Hypothesis. JavaScript/TypeScript: fast-check. Haskell: QuickCheck. Rust: quickcheck.
Java: jqwik. C#: FsCheck. Adopted by Amazon, Volvo, Stripe, Jane Street (ICSE 2024 study).

## When PBT Adds Value (vs overkill)
HIGH value: algorithms, data structures, serialization, business rules (validation, calculations), protocols/state machines.
LOW value: simple CRUD, UI logic, external API integrations.
PBT complements example-based testing, doesn't replace it.

## PBT + TDD Integration
1. Start with example-based TDD for specific cases (drives detailed design)
2. Once basic implementation works, write properties to generalize
3. If property fails: found bug or need refined implementation
4. Refactor freely - properties verify behavior preservation
Properties = higher-level spec that survives refactoring better than examples.

## Mutation Testing
Evaluates test suite quality by introducing artificial bugs (mutations) and checking if tests catch them.
Mutation score = killed mutants / total mutants. Stronger metric than code coverage (measures assertions, not just execution).

## Mutation Score Targets
< 60%: weak suite, significant gaps. 60-80%: moderate, some gaps.
> 80%: strong, few gaps. Target: 75-80% minimum for nWave.
Not all survivors indicate bad tests (equivalent mutants exist).

## Mutation Operators
Change == to !=, + to -, remove method call, change constant, modify loop boundary, alter comparison in convergence.

## Mutation Testing Tools
Java: PIT. JavaScript/TypeScript/C#: Stryker. Python: mutmut, Cosmic Ray.
Computationally expensive (N mutants x full test suite). Use incremental: on changed code in PRs, full codebase weekly.

## Combined PBT + Mutation Workflow
1. Write example-based tests (TDD) -> cover known scenarios
2. Apply mutation testing -> identify assertion gaps -> write more tests
3. Add PBT for complex logic -> cover input space systematically
4. Mutation testing again -> verify properties are comprehensive
Quality ratchet: each technique exposes gaps others miss. Prioritize critical paths and complex algorithms.

## PBT Performance Guidance
Fast feedback: ~100 examples. CI/CD: ~1000. Nightly builds: ~10000+.
Modern frameworks allow configuring example count per context.
