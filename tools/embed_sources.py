#!/usr/bin/env python3
"""
Source Embedding Tool for nWave Framework

Embeds source files into target documents using markers. This enables maintaining
a single source of truth (the original files) while automatically embedding them
into documentation and task files during the build process.

Marker Format:
    <!-- EMBED_START:path/to/source.py:format -->
    (existing content will be replaced)
    <!-- EMBED_END:path/to/source.py -->

Supported Formats:
    - python_string: Escape as a Python multiline string variable
    - markdown_code: Wrap in markdown code fence with syntax highlighting
    - raw: Insert file content as-is

Usage:
    python tools/embed_sources.py [--dry-run] [--verbose] [target_files...]

    If no target files specified, scans all .md files in nWave/tasks/

Examples:
    # Process all task files
    python tools/embed_sources.py

    # Process specific file
    python tools/embed_sources.py nWave/tasks/nw/develop.md

    # Dry run (show what would change)
    python tools/embed_sources.py --dry-run

Exit Codes:
    0 - Success
    1 - Errors occurred
    2 - Configuration error
"""

import argparse
import glob
import os
import re
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple


# Marker patterns
EMBED_START_PATTERN = re.compile(r"<!--\s*EMBED_START:([^:]+):(\w+)\s*-->")
EMBED_END_PATTERN = re.compile(r"<!--\s*EMBED_END:([^>]+)\s*-->")


def get_project_root() -> Path:
    """Get the project root directory."""
    # This script is in tools/, so parent is project root
    return Path(__file__).parent.parent


def read_source_file(source_path: str) -> Optional[str]:
    """
    Read a source file relative to project root.

    Args:
        source_path: Path relative to project root

    Returns:
        File content or None if not found
    """
    project_root = get_project_root()
    full_path = project_root / source_path

    if not full_path.exists():
        print(f"  [ERROR] Source file not found: {source_path}", file=sys.stderr)
        return None

    try:
        with open(full_path, "r", encoding="utf-8") as f:
            return f.read()
    except Exception as e:
        print(f"  [ERROR] Cannot read {source_path}: {e}", file=sys.stderr)
        return None


def format_as_python_string(content: str, source_path: str) -> str:
    """
    Format content as an embedded Python string variable.

    The output can be used directly in Python code to write the content to a file.
    """
    # Variable name from filename (e.g., pre_commit_tdd_phases.py -> PRE_COMMIT_TDD_PHASES_PY)
    filename = os.path.basename(source_path)
    var_name = filename.upper().replace(".", "_").replace("-", "_")

    # Escape for Python string (triple-quoted, so minimal escaping needed)
    # Only escape backslashes and triple quotes
    escaped = content.replace("\\", "\\\\").replace('"""', '\\"\\"\\"')

    lines = [
        f"# EMBEDDED FROM: {source_path}",
        f"# Generated by: tools/embed_sources.py",
        f"# DO NOT EDIT BETWEEN MARKERS - changes will be overwritten",
        f"",
        f'{var_name} = """',
        escaped,
        '"""',
    ]

    return "\n".join(lines)


def format_as_markdown_code(content: str, source_path: str) -> str:
    """
    Format content as a markdown code block with syntax highlighting.
    """
    # Determine language from extension
    ext = os.path.splitext(source_path)[1].lower()
    lang_map = {
        ".py": "python",
        ".js": "javascript",
        ".ts": "typescript",
        ".sh": "bash",
        ".yaml": "yaml",
        ".yml": "yaml",
        ".json": "json",
        ".md": "markdown",
        ".cs": "csharp",
    }
    lang = lang_map.get(ext, "")

    lines = [
        f"<!-- EMBEDDED FROM: {source_path} -->",
        f"<!-- Generated by: tools/embed_sources.py -->",
        f"<!-- DO NOT EDIT BETWEEN MARKERS - changes will be overwritten -->",
        "",
        f"```{lang}",
        content.rstrip(),
        "```",
    ]

    return "\n".join(lines)


def format_as_raw(content: str, source_path: str) -> str:
    """
    Format content as-is with minimal header.
    """
    lines = [
        f"<!-- EMBEDDED FROM: {source_path} -->",
        content,
    ]

    return "\n".join(lines)


def format_content(content: str, source_path: str, format_type: str) -> Optional[str]:
    """
    Format content according to the specified format type.

    Args:
        content: Source file content
        source_path: Path to source file (for metadata)
        format_type: One of: python_string, markdown_code, raw

    Returns:
        Formatted content or None if format not supported
    """
    formatters = {
        "python_string": format_as_python_string,
        "markdown_code": format_as_markdown_code,
        "raw": format_as_raw,
    }

    formatter = formatters.get(format_type)
    if not formatter:
        print(f"  [ERROR] Unknown format type: {format_type}", file=sys.stderr)
        print(
            f"          Supported formats: {', '.join(formatters.keys())}",
            file=sys.stderr,
        )
        return None

    return formatter(content, source_path)


def process_file(
    file_path: str, dry_run: bool = False, verbose: bool = False
) -> Tuple[bool, int]:
    """
    Process a single file, replacing embed markers with source content.

    Args:
        file_path: Path to the file to process
        dry_run: If True, don't write changes
        verbose: If True, print detailed info

    Returns:
        Tuple of (success: bool, embeddings_count: int)
    """
    if verbose:
        print(f"\nProcessing: {file_path}")

    try:
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()
    except Exception as e:
        print(f"  [ERROR] Cannot read file: {e}", file=sys.stderr)
        return False, 0

    # Find all EMBED_START markers
    starts = list(EMBED_START_PATTERN.finditer(content))

    if not starts:
        if verbose:
            print(f"  No embed markers found")
        return True, 0

    embeddings_count = 0
    errors = 0
    new_content = content
    offset = 0  # Track offset as we make replacements

    for start_match in starts:
        source_path = start_match.group(1).strip()
        format_type = start_match.group(2).strip()

        if verbose:
            print(f"  Found: {source_path} (format: {format_type})")

        # Find corresponding END marker
        # Search from after the START marker
        search_start = start_match.end() + offset
        remaining_content = new_content[search_start:]

        end_pattern = re.compile(rf"<!--\s*EMBED_END:{re.escape(source_path)}\s*-->")
        end_match = end_pattern.search(remaining_content)

        if not end_match:
            print(
                f"  [ERROR] No matching EMBED_END for: {source_path}", file=sys.stderr
            )
            errors += 1
            continue

        # Read source file
        source_content = read_source_file(source_path)
        if source_content is None:
            errors += 1
            continue

        # Format content
        formatted = format_content(source_content, source_path, format_type)
        if formatted is None:
            errors += 1
            continue

        # Calculate absolute positions
        start_pos = start_match.end() + offset
        end_pos = search_start + end_match.start()

        # Replace content between markers (preserve markers themselves)
        old_len = end_pos - start_pos
        new_len = len(formatted) + 2  # +2 for newlines

        replacement = f"\n{formatted}\n"
        new_content = new_content[:start_pos] + replacement + new_content[end_pos:]

        # Update offset for next iteration
        offset += len(replacement) - old_len
        embeddings_count += 1

        if verbose:
            print(f"    Embedded {len(source_content)} chars")

    if errors > 0:
        return False, embeddings_count

    # Check if content changed
    if new_content == content:
        if verbose:
            print(f"  No changes needed")
        return True, embeddings_count

    # Write back
    if dry_run:
        print(f"  [DRY RUN] Would update {file_path} ({embeddings_count} embeddings)")
    else:
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(new_content)
            print(f"  [OK] Updated {file_path} ({embeddings_count} embeddings)")
        except Exception as e:
            print(f"  [ERROR] Cannot write file: {e}", file=sys.stderr)
            return False, embeddings_count

    return True, embeddings_count


def find_target_files(paths: List[str]) -> List[str]:
    """
    Find all target files to process.

    If paths is empty, scans default locations.
    """
    if paths:
        # Expand globs if needed
        result = []
        for path in paths:
            if "*" in path:
                result.extend(glob.glob(path, recursive=True))
            else:
                result.append(path)
        return result

    # Default: scan nWave/tasks/**/*.md
    project_root = get_project_root()
    patterns = [
        "nWave/tasks/**/*.md",
        "nWave/data/**/*.md",
    ]

    result = []
    for pattern in patterns:
        full_pattern = str(project_root / pattern)
        result.extend(glob.glob(full_pattern, recursive=True))

    return sorted(set(result))


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Embed source files into target documents",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be changed without modifying files",
    )
    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Print detailed processing information",
    )
    parser.add_argument(
        "files",
        nargs="*",
        help="Target files to process (default: nWave/tasks/**/*.md)",
    )

    args = parser.parse_args()

    print("nWave Source Embedding Tool")
    print("=" * 50)

    if args.dry_run:
        print("[DRY RUN MODE - No files will be modified]\n")

    # Find target files
    target_files = find_target_files(args.files)

    if not target_files:
        print("No target files found.", file=sys.stderr)
        return 2

    print(f"Found {len(target_files)} file(s) to scan\n")

    # Process each file
    total_embeddings = 0
    errors = 0

    for file_path in target_files:
        success, count = process_file(file_path, args.dry_run, args.verbose)
        total_embeddings += count
        if not success:
            errors += 1

    # Summary
    print("\n" + "=" * 50)
    print("Summary:")
    print(f"  Files scanned: {len(target_files)}")
    print(f"  Total embeddings: {total_embeddings}")
    print(f"  Errors: {errors}")

    if args.dry_run:
        print("\n[DRY RUN] No files were modified.")
        print("Run without --dry-run to apply changes.")

    return 1 if errors > 0 else 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nInterrupted", file=sys.stderr)
        sys.exit(130)
