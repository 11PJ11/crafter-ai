---
feature: des-hook-enforcement
version: 1.0.0
created: 2026-02-01
methodology: nWave ATDD with Outside-In TDD
complexity: intermediate

# Quality Gate Validation
quality_gates:
  ac_abstraction_level: "All AC describe WHAT the system does, never HOW (no private methods, no internal structure)"
  step_decomposition_efficiency: "Steps decomposed by implementation unit, not by test scenario"
  step_to_file_ratio: "7 steps / 7 files = 1.0 (target: <= 2.5)"
  identical_pattern_batching: "Pre-task and SubagentStop handlers in single adapter file"
  test_theatre_prevention:
    walking_skeleton: "Step 00-01 proves runtime hook firing BEFORE component implementation (catches wiring failures in 1h, not 15h)"
    mutation_testing: "Handled by /nw:develop Phase 2.25 (80% kill rate threshold enforced automatically)"
    e2e_coverage: "Step 03-01 E2E tests exercise complete Claude Code → adapter → audit path"
    negative_testing: "Uninstall E2E test proves hooks DON'T fire when removed"

baseline_measurement:
  problem_description: "DES hooks are purely advisory — no proof they fire, no enforcement, easily bypassed"
  current_state: |
    - validate_prompt() and on_agent_complete() require manual invocation by orchestrator
    - ClaudeCodeTaskAdapter raises NotImplementedError (never implemented)
    - on_agent_complete() is never called in production
    - No observable proof hooks fired when validation passes
    - Pre-commit hooks bypassed via --no-verify (proven by investigation)
  impact: "DES execution tracking provides zero guarantees — audit trail has no evidence hooks participated"
  measurement_data:
    hook_invocations_with_proof: 0  # No audit trail entries for hook execution
    bypass_methods_available: 2  # --no-verify, skip orchestrator entirely
    audit_event_types_unused: 3  # TASK_INVOCATION_REJECTED, SUBAGENT_STOP_VALIDATION, SUBAGENT_STOP_FAILURE
    observable_hook_executions: 0  # Cannot prove any hook ever fired
  target_state: "Non-bypassable hooks with tamper-evident audit proof of every execution"
  success_criteria:
    - Every Task tool invocation produces HOOK_PRE_TASK_PASSED or HOOK_PRE_TASK_BLOCKED in audit log (when audit enabled)
    - Every sub-agent completion produces HOOK_SUBAGENT_STOP_PASSED or HOOK_SUBAGENT_STOP_FAILED in audit log (when audit enabled)
    - Hooks cannot be bypassed (Claude Code runtime enforcement, not Python advisory)
    - SubagentStop blocks orchestrator from continuing when validation fails
    - All timestamps via TimeProvider.now_utc() (testable, reliable, UTC-only)
    - Cross-platform (Python entry points, no shell scripts)
    - Audit logging configurable via ~/.claude/des/config.yaml (default enabled, user can disable)
    - Hook configuration managed via installer/uninstaller (no manual editing, no corruption, no traces after uninstall)

implementation_scope:
  directories:
    - src/des/adapters/drivers/hooks/  # Hook adapter (new + modified)
    - src/des/adapters/driven/logging/  # Audit events (modified)
    - src/des/adapters/driven/config/  # Configuration infrastructure (new)
    - src/des/application/  # Orchestrator (modified)
    - scripts/install/  # Hook installer (new)
  files_created:
    - src/des/adapters/driven/config/des_config.py  # Configuration loader
    - ~/.claude/des/config.yaml  # DES configuration (audit_logging_enabled, etc)
    - src/des/adapters/drivers/hooks/claude_code_hook_adapter.py  # Protocol translator
    - scripts/install/install_des_hooks.py  # Hook installer/uninstaller
  files_modified:
    - src/des/adapters/driven/logging/audit_events.py  # 4 new HOOK event types
    - src/des/application/orchestrator.py  # Rejection audit logging
    - src/des/adapters/drivers/hooks/real_hook.py  # Post-execution audit logging
    - .claude/settings.local.json  # Merged hook configuration (via installer)
  excluded:
    - src/des/adapters/driven/task_invocation/claude_code_task_adapter.py  # Architectural boundary, leave as stub
    - src/des/adapters/driven/logging/audit_logger.py  # Already complete
    - src/des/ports/driver_ports/hook_port.py  # Interface unchanged

design_decisions:
  enforcement_layer:
    chosen: "Claude Code native hooks (PreToolUse, SubagentStop)"
    rejected: "Python wrapper around orchestrator"
    rationale: "Python libraries cannot enforce their own invocation — enforcement must live at the runtime layer"

  entry_point_language:
    chosen: "Python (cross-platform)"
    rejected: "Bash shell scripts"
    rationale: "Shell scripts do not work on Windows; Python runs everywhere"

  timestamp_strategy:
    chosen: "TimeProvider.now_utc() via dependency injection"
    rejected: "datetime.now(), time.time(), system-local time"
    rationale: "Testable with FakeTimeProvider, reliable UTC-only, already implemented in SystemTimeProvider"

  subagent_stop_behavior:
    chosen: "Blocking gate (exit 2 = BLOCK orchestrator)"
    rejected: "Informational (log only, always exit 0)"
    rationale: "Must prevent orchestrator from continuing when phases incomplete or validation fails"

  fail_closed:
    chosen: "Any error in hook = BLOCK (non-zero exit)"
    rejected: "Fail-open (allow on error)"
    rationale: "Cannot validate = cannot proceed; security-critical path must fail closed"

  audit_log_activation:
    chosen: "Configurable via ~/.claude/des/config.yaml (default: enabled)"
    rejected: "Always-on hardcoded logging"
    rationale: "Users must control audit verbosity; default enabled for security, but allow disable for testing/privacy"

  hook_configuration_lifecycle:
    chosen: "Managed installation/uninstallation via installer script"
    rejected: "Manual .claude/settings.local.json editing"
    rationale: "Must merge with existing config, uninstall cleanly, leave no traces or corruption"

tdd_phases:
  - PREPARE
  - RED_ACCEPTANCE
  - RED_UNIT
  - GREEN
  - REVIEW
  - REFACTOR_CONTINUOUS
  - COMMIT

execution_config:
  max_turns_per_step: 50
  checkpoint_strategy: "3 strategic checkpoints (GREEN, REVIEW, FINAL)"

steps:
  # PHASE 0: Walking Skeleton (1 step — prove hook firing BEFORE building components)
  - id: "00-01"
    phase: 0
    type: spike
    title: "Walking Skeleton: Prove Claude Code hook firing end-to-end"
    description: |
      Create minimal stub adapter that proves Claude Code runtime can invoke our hook.
      This validates wiring (JSON protocol, matcher, exit codes) BEFORE building complex components.
      Prevents Test Theatre by catching integration failures in 1 hour, not after 15 hours.

    acceptance_criteria:
      - Stub adapter created at src/des/adapters/drivers/hooks/claude_code_hook_adapter.py
      - Stub reads JSON from stdin without error
      - Stub outputs valid JSON to stdout {"decision":"allow","proof":"hook_fired"}
      - Stub exits with code 0 (success)
      - Manual .claude/settings.local.json created with PreToolUse hook entry matching "Task" tool
      - After Claude Code session restart, invoke Task tool with any prompt
      - Verify stub adapter executed (evidence stdout contains proof marker or log entry)
      - Proves Claude Code CAN invoke Python script, JSON protocol works, matcher works

    deliverables:
      - Minimal working hook adapter stub (will be replaced in step 02-02)
      - Proof of correct Claude Code hook protocol (JSON stdin/stdout, exit codes)
      - Evidence that "Task" matcher triggers hook
      - Manual settings.local.json for testing (will be replaced by installer in step 03-01)

    implementation_notes:
      files_to_create:
        - src/des/adapters/drivers/hooks/claude_code_hook_adapter.py  # Stub version
      stub_behavior: "Read stdin, output success JSON, exit 0 — no DES logic yet"
      manual_config: |
        Create .claude/settings.local.json manually for testing:
        {
          "hooks": {
            "PreToolUse": [
              {
                "matcher": "Task",
                "command": "python3 src/des/adapters/drivers/hooks/claude_code_hook_adapter.py pre-task"
              }
            ]
          }
        }

    test_strategy:
      manual_verification:
        - "Create stub adapter with minimal JSON I/O"
        - "Manually create .claude/settings.local.json with hook entry"
        - "Restart Claude Code session to load new settings"
        - "Invoke Task tool (any agent, any prompt)"
        - "Observe stdout/logs for proof hook executed"
        - "SUCCESS Hook fired and returned valid JSON"
        - "FAILURE Hook never fired OR invalid JSON OR wrong exit code → fix before proceeding"
      validation:
        - "Hook adapter stub exists and is executable"
        - "JSON protocol works (Claude Code can parse our output)"
        - "Matcher Task triggers hook correctly"

    estimated_time: "1 hour"
    suggested_agent: software-crafter
    dependencies: []

    acceptance_test_file: "tests/des/acceptance/test_hook_enforcement.feature"
    acceptance_test_scenarios:
      - name: "Stub hook adapter executes and proves hook firing"
        line: 11
        description: "Validates Claude Code can invoke Python hook adapter, JSON protocol works, and hook firing is observable"

  # PHASE 1: Audit Infrastructure (3 steps — foundation for observability)
  - id: "01-01"
    phase: 1
    type: infrastructure
    title: "Add hook audit event types"
    description: "Define 4 new HOOK event types in the audit events enum for observable proof of hook execution"

    acceptance_criteria:
      - EventType enum contains HOOK_PRE_TASK_PASSED for successful pre-task validation
      - EventType enum contains HOOK_PRE_TASK_BLOCKED for rejected pre-task validation
      - EventType enum contains HOOK_SUBAGENT_STOP_PASSED for successful post-execution gate
      - EventType enum contains HOOK_SUBAGENT_STOP_FAILED for failed post-execution gate
      - get_event_category() returns "HOOK" for all 4 new event types
      - validate_event_type() accepts all 4 new event types
      - Existing event types unchanged and functional

    implementation_notes:
      files_to_modify:
        - src/des/adapters/driven/logging/audit_events.py
      change_scope: "Add 4 enum values + update get_event_category() for HOOK prefix"
      existing_patterns: "Follow TASK_INVOCATION, PHASE, SUBAGENT_STOP naming convention"

    test_strategy:
      unit_tests:
        - "HOOK_PRE_TASK_PASSED is valid EventType enum member"
        - "HOOK_PRE_TASK_BLOCKED is valid EventType enum member"
        - "HOOK_SUBAGENT_STOP_PASSED is valid EventType enum member"
        - "HOOK_SUBAGENT_STOP_FAILED is valid EventType enum member"
        - "get_event_category returns HOOK for all 4 new types"
        - "validate_event_type accepts all 4 new types"
        - "Existing event types still valid (no regression)"

    estimated_time: "1 hour"
    suggested_agent: software-crafter
    dependencies: []

    acceptance_test_file: "tests/des/acceptance/test_hook_enforcement.feature"
    acceptance_test_scenarios:
      - name: "Hook audit event types are defined and validated"
        line: 23
        description: "Validates 4 new HOOK event types exist, return correct category, and existing events unchanged"

  - id: "01-02"
    phase: 1
    type: feature
    title: "Add rejection audit logging to orchestrator"
    description: "Instrument validate_prompt() to log both PASSED and BLOCKED outcomes via AuditLogger"

    acceptance_criteria:
      - validate_prompt() logs HOOK_PRE_TASK_PASSED when task_invocation_allowed=True
      - validate_prompt() logs HOOK_PRE_TASK_BLOCKED when task_invocation_allowed=False
      - Audit log entry includes step_path, agent name, and rejection reason (when blocked)
      - All timestamps produced by TimeProvider.now_utc() (not datetime.now())
      - Existing validate_prompt() return value unchanged
      - Existing orchestrator behavior unchanged for callers

    implementation_notes:
      files_to_modify:
        - src/des/application/orchestrator.py
      key_change: "Add audit_logger.log_event() calls in validate_prompt() for both outcomes"
      timestamp_source: "self._time_provider.now_utc() — already injected into orchestrator"
      existing_code_reference: "validate_prompt() currently has no logging on success path"

    test_strategy:
      unit_tests:
        - "validate_prompt() with valid prompt logs HOOK_PRE_TASK_PASSED"
        - "validate_prompt() with invalid prompt logs HOOK_PRE_TASK_BLOCKED"
        - "Audit log entry timestamp comes from TimeProvider (verified via FakeTimeProvider)"
        - "Audit log entry contains step_path and agent context"
        - "validate_prompt() return value unchanged (no behavioral regression)"
      validation:
        - "Existing orchestrator tests still pass"

    estimated_time: "2 hours"
    suggested_agent: software-crafter
    dependencies: ["01-01"]

    acceptance_test_file: "tests/des/acceptance/test_hook_enforcement.feature"
    acceptance_test_scenarios:
      - name: "Valid task invocation produces HOOK_PRE_TASK_PASSED audit entry"
        line: 38
        description: "Validates successful task validation creates audit entry with step_path, agent, and UTC timestamp"
      - name: "Invalid task invocation produces HOOK_PRE_TASK_BLOCKED audit entry"
        line: 49
        description: "Validates rejected task validation creates audit entry with rejection reason and UTC timestamp"

  - id: "01-03"
    phase: 1
    type: feature
    title: "Add audit logging to SubagentStop hook"
    description: "Instrument on_agent_complete() to log PASSED/FAILED outcomes via AuditLogger"

    acceptance_criteria:
      - on_agent_complete() logs HOOK_SUBAGENT_STOP_PASSED when validation succeeds
      - on_agent_complete() logs HOOK_SUBAGENT_STOP_FAILED when validation fails
      - Audit log entry includes step_path, phases_validated count, and errors (when failed)
      - All timestamps produced by TimeProvider.now_utc()
      - Existing on_agent_complete() return value unchanged

    implementation_notes:
      files_to_modify:
        - src/des/adapters/drivers/hooks/real_hook.py
      key_change: "Add audit_logger.log_event() calls in on_agent_complete() for both outcomes"
      timestamp_source: "TimeProvider injected via constructor (add if not present)"

    test_strategy:
      unit_tests:
        - "on_agent_complete() with successful validation logs HOOK_SUBAGENT_STOP_PASSED"
        - "on_agent_complete() with failed validation logs HOOK_SUBAGENT_STOP_FAILED"
        - "Audit log entry timestamp comes from TimeProvider"
        - "Audit log entry contains phases_validated and error details"
        - "Existing on_agent_complete() behavior unchanged"

    estimated_time: "2 hours"
    suggested_agent: software-crafter
    dependencies: ["01-01"]

    acceptance_test_file: "tests/des/acceptance/test_hook_enforcement.feature"
    acceptance_test_scenarios:
      - name: "Successful post-execution gate produces HOOK_SUBAGENT_STOP_PASSED"
        line: 62
        description: "Validates successful sub-agent completion creates audit entry with step_path, phases_validated, and UTC timestamp"
      - name: "Failed post-execution gate produces HOOK_SUBAGENT_STOP_FAILED"
        line: 74
        description: "Validates failed sub-agent validation creates audit entry with validation errors and UTC timestamp"

  # PHASE 2: Configuration + Protocol Translator (2 steps)
  - id: "02-01"
    phase: 2
    type: infrastructure
    title: "Create DES configuration infrastructure"
    description: |
      Create configuration system for DES settings (audit logging control, etc).
      Default: audit_logging_enabled = true, user can disable via config file.

    acceptance_criteria:
      - Configuration file created at ~/.claude/des/config.yaml with default settings
      - DESConfig class loads configuration from YAML file
      - audit_logging_enabled setting defaults to true
      - Hook adapter can check config.audit_logging_enabled before logging
      - Configuration file includes comments explaining each setting
      - Invalid/missing config file falls back to safe defaults (audit enabled)

    implementation_notes:
      files_to_create:
        - src/des/adapters/driven/config/des_config.py  # Configuration loader
        - ~/.claude/des/config.yaml  # Default configuration template
      default_configuration: |
        # DES (Deterministic Execution System) Configuration
        # Created: 2026-02-01

        # Audit Logging
        # Controls whether hooks log execution to audit trail
        # Default: true (recommended for production)
        audit_logging_enabled: true

        # Future settings can be added here
      architecture: "Driven adapter in hexagonal architecture (configuration port)"
      fallback_behavior: "Missing/invalid config → use safe defaults (audit enabled)"

    test_strategy:
      unit_tests:
        - "DESConfig loads configuration from valid YAML file"
        - "DESConfig.audit_logging_enabled returns true by default"
        - "DESConfig handles missing config file gracefully (returns defaults)"
        - "DESConfig handles invalid YAML gracefully (returns defaults)"
        - "Hook adapter can import and use DESConfig"

    estimated_time: "2 hours"
    suggested_agent: software-crafter
    dependencies: ["01-01"]

    acceptance_test_file: "tests/des/acceptance/test_hook_enforcement.feature"
    acceptance_test_scenarios:
      - name: "DES configuration loads from YAML file with defaults"
        line: 88
        description: "Validates config file created with audit_logging_enabled=true default and explanatory comments"
      - name: "DES configuration falls back to safe defaults when file is invalid"
        line: 95
        description: "Validates invalid/missing config handled gracefully with audit_logging_enabled=true default"
      - name: "Hook adapter can check audit logging configuration"
        line: 101
        description: "Validates hook adapter can read config.audit_logging_enabled setting"

  - id: "02-02"
    phase: 2
    type: feature
    title: "Create Claude Code hook adapter with config checking"
    description: |
      Create the Python adapter that bridges Claude Code's hook protocol (JSON stdin/stdout, exit codes)
      to DES domain logic (validate_prompt, on_agent_complete). Checks DESConfig before logging.
      Single file, no shell wrappers. Follows existing pattern from nWave/hooks/discover_subagent_context.py.

    acceptance_criteria:
      # Pre-task handler
      - Adapter reads JSON from stdin following Claude Code hook protocol
      - Pre-task command extracts prompt from tool_input and calls DESOrchestrator.validate_prompt()
      - 'Pre-task outputs JSON {"decision": "allow"} and exits 0 when validation passes'
      - 'Pre-task outputs JSON {"decision": "block", "reason": "..."} and exits 2 when validation rejects'
      - 'Pre-task outputs JSON {"decision": "block", "reason": "<error>"} and exits 1 on fail-closed errors'
      # SubagentStop handler (BLOCKING GATE)
      - SubagentStop command calls RealSubagentStopHook.on_agent_complete()
      - SubagentStop exits 0 when post-execution gate passes (orchestrator may continue)
      - SubagentStop exits 2 when post-execution gate fails (orchestrator BLOCKED from continuing)
      - 'SubagentStop outputs JSON {"status": "error", "reason": "<error>"} and exits 1 on fail-closed errors'
      # Audit logging control
      - Adapter checks DESConfig.audit_logging_enabled before logging
      - When audit_logging_enabled=false, hooks execute validation but skip audit log writes
      - Validation and exit codes work identically regardless of audit logging setting
      # Timestamps
      - All timestamps produced by SystemTimeProvider.now_utc() (never datetime.now())
      # Fail-closed
      - Invalid or missing stdin JSON causes exit 1 (BLOCK) with error JSON output
      - Unhandled exceptions cause exit 1 (BLOCK) with error JSON output
      - Import failures cause exit 1 (BLOCK)
      # Cross-platform
      - No shell scripts, no bash, no OS-specific commands
      - Invocable via: python3 src/des/adapters/drivers/hooks/claude_code_hook_adapter.py {pre-task|subagent-stop}

    implementation_notes:
      files_to_create:
        - src/des/adapters/drivers/hooks/claude_code_hook_adapter.py
      architecture: "Driver adapter in hexagonal architecture (sits between Claude Code runtime and DES domain)"
      existing_pattern: "nWave/hooks/discover_subagent_context.py — reads stdin JSON, outputs JSON to stdout, uses exit codes"
      cli_interface: "python3 claude_code_hook_adapter.py {pre-task|subagent-stop}"
      dependencies_used:
        - DESOrchestrator (src/des/application/orchestrator.py)
        - RealSubagentStopHook (src/des/adapters/drivers/hooks/real_hook.py)
        - SystemTimeProvider (src/des/adapters/driven/time/system_time.py)
        - AuditLogger (src/des/adapters/driven/logging/audit_logger.py)
        - DESConfig (src/des/adapters/driven/config/des_config.py)

    test_strategy:
      unit_tests:
        - "handle_pre_task with valid JSON and passing validation returns exit 0"
        - "handle_pre_task with valid JSON and failing validation returns exit 2"
        - "handle_pre_task with invalid JSON returns exit 1 with error JSON output"
        - "handle_pre_task with missing stdin returns exit 1 with error JSON output"
        - "handle_subagent_stop with passing gate returns exit 0"
        - "handle_subagent_stop with failing gate returns exit 2 (BLOCKS orchestrator)"
        - "handle_subagent_stop with invalid JSON returns exit 1 with error JSON output"
        - "All timestamps produced by TimeProvider (verified via FakeTimeProvider injection)"
        - "Pre-task outputs valid JSON to stdout (both success and error cases)"
        - "SubagentStop outputs valid JSON to stdout (both success and error cases)"
        - "Adapter checks DESConfig.audit_logging_enabled before logging"
        - "When audit_logging_enabled=false, validation executes but no audit log entries created"
        - "When audit_logging_enabled=true, audit log entries created normally"
      end_to_end_tests:
        - "E2E: pipe valid Task JSON to adapter → exit 0 + audit log entry (when audit enabled)"
        - "E2E: pipe invalid Task JSON to adapter → exit 2 + audit log entry (when audit enabled)"
        - "E2E: pipe valid Task JSON with audit disabled → exit 0 + NO audit log entry"

    estimated_time: "5 hours"
    suggested_agent: software-crafter
    dependencies: ["01-02", "01-03", "02-01"]

    acceptance_test_file: "tests/des/acceptance/test_hook_enforcement.feature"
    acceptance_test_scenarios:
      - name: "Pre-task hook allows valid task and logs audit entry"
        line: 107
        description: "Validates adapter exits 0, outputs allow JSON, and creates HOOK_PRE_TASK_PASSED audit entry for valid task"
      - name: "Pre-task hook blocks invalid task and logs audit entry"
        line: 117
        description: "Validates adapter exits 2, outputs block JSON with reason, and creates HOOK_PRE_TASK_BLOCKED audit entry"
      - name: "Pre-task hook skips audit logging when disabled in config"
        line: 129
        description: "Validates adapter respects config.audit_logging_enabled=false (validates but doesn't log)"
      - name: "SubagentStop hook passes when validation succeeds"
        line: 137
        description: "Validates adapter exits 0 and creates HOOK_SUBAGENT_STOP_PASSED audit entry when step complete"
      - name: "SubagentStop hook blocks when validation fails"
        line: 148
        description: "Validates adapter exits 2 (BLOCKS orchestrator) and creates HOOK_SUBAGENT_STOP_FAILED audit entry when step incomplete"
      - name: "Pre-task hook fails closed on invalid JSON input"
        line: 159
        description: "Validates adapter exits 1 with error JSON when input is malformed (fail-closed security)"
      - name: "Pre-task hook fails closed on missing stdin"
        line: 166
        description: "Validates adapter exits 1 with error JSON when stdin is missing (fail-closed security)"
      - name: "SubagentStop hook fails closed on unhandled exception"
        line: 172
        description: "Validates adapter exits 1 with error JSON when unexpected exception occurs (fail-closed security)"
      - name: "Hook adapter works cross-platform via Python entry point"
        line: 180
        description: "Validates adapter executes on all platforms (Windows, macOS, Linux) with no shell dependencies"

  # PHASE 3: Hook Installation (1 step — managed lifecycle)
  - id: "03-01"
    phase: 3
    type: installation
    title: "Create hook installer with install/uninstall lifecycle"
    description: |
      Create installer script that manages DES hook configuration lifecycle.
      Merges hooks into existing .claude/settings.local.json, preserves other hooks,
      uninstalls cleanly without leaving traces or corrupting configuration.

    acceptance_criteria:
      # Installation
      - Installer script install_des_hooks.py executable via: python3 scripts/install/install_des_hooks.py --install
      - Install merges DES hooks into existing .claude/settings.local.json (preserves other hooks)
      - Install creates .claude/settings.local.json if file does not exist
      - Install detects if DES hooks already installed (idempotent)
      - After install + session restart, hooks fire on Task tool invocation
      - PreToolUse hook configured with matcher "Task" pointing to Python adapter
      - SubagentStop hook configured pointing to Python adapter
      - Hook commands use python3 (not bash, not shell)
      # Uninstallation
      - Uninstaller removes ONLY DES hook entries from .claude/settings.local.json
      - Uninstaller preserves all non-DES hooks in configuration
      - Uninstaller handles missing .claude/settings.local.json gracefully (no error)
      - After uninstall, .claude/settings.local.json validates as valid JSON
      - After uninstall, no traces of DES hooks remain in configuration
      # Observability
      - After install, audit log shows HOOK_PRE_TASK_PASSED for valid Task invocations
      - After install, audit log shows HOOK_SUBAGENT_STOP_PASSED or HOOK_SUBAGENT_STOP_FAILED after sub-agent completes
      - After uninstall, hooks do not fire (no audit log entries)

    implementation_notes:
      files_to_create:
        - scripts/install/install_des_hooks.py
      cli_interface: |
        python3 scripts/install/install_des_hooks.py --install   # Install hooks
        python3 scripts/install/install_des_hooks.py --uninstall # Remove hooks
        python3 scripts/install/install_des_hooks.py --status    # Check if installed
      hook_configuration_to_merge: |
        {
          "hooks": {
            "PreToolUse": [
              {
                "matcher": "Task",
                "command": "python3 src/des/adapters/drivers/hooks/claude_code_hook_adapter.py pre-task"
              }
            ],
            "SubagentStop": [
              {
                "command": "python3 src/des/adapters/drivers/hooks/claude_code_hook_adapter.py subagent-stop"
              }
            ]
          }
        }
      merge_strategy: |
        1. Load existing .claude/settings.local.json (or create empty if missing)
        2. Merge DES hooks into hooks.PreToolUse array (append, don't replace)
        3. Merge DES hooks into hooks.SubagentStop array (append, don't replace)
        4. Write back to .claude/settings.local.json with proper JSON formatting
      uninstall_strategy: |
        1. Load existing .claude/settings.local.json
        2. Filter out hook entries matching DES adapter command
        3. Write back cleaned configuration
        4. If hooks section becomes empty, preserve empty arrays (valid JSON)
      activation: "Requires Claude Code session restart to take effect"
      proven_pattern: "nWave/hooks/discover_subagent_context.py already uses python3 command in hooks"

    test_strategy:
      unit_tests:
        - "Installer merges DES hooks into existing .claude/settings.local.json"
        - "Installer creates .claude/settings.local.json if missing"
        - "Installer detects already-installed hooks (idempotent)"
        - "Uninstaller removes only DES hooks, preserves others"
        - "Uninstaller handles missing file gracefully"
        - "Merged configuration validates as valid JSON"
        - "Status command detects installed vs not-installed state"
      end_to_end_tests:
        - "E2E install: Run installer → verify .claude/settings.local.json contains DES hooks"
        - "E2E install: Merged settings.local.json validates as valid JSON"
        - "E2E install: After session restart, invoke Task tool → verify HOOK_PRE_TASK_PASSED in audit log"
        - "E2E install: After sub-agent completes → verify HOOK_SUBAGENT_STOP_PASSED in audit log"
        - "E2E install: Send invalid prompt via Task → verify HOOK_PRE_TASK_BLOCKED and Task prevented"
        - "E2E uninstall: Run uninstaller → verify DES hooks removed from settings.local.json"
        - "E2E uninstall: After session restart → verify hooks no longer fire (no audit log entries)"
        - "E2E preservation: Install with existing hooks → verify existing hooks preserved"
        - "E2E preservation: Uninstall with other hooks → verify other hooks still present"
      cross_platform:
        - "Installer works on Windows (Python, no shell)"
        - "Installer works on Linux"
        - "Installer works on macOS"
        - "Hooks execute on all platforms after install"

    estimated_time: "3 hours"
    suggested_agent: software-crafter
    dependencies: ["02-02"]

    acceptance_test_file: "tests/des/acceptance/test_hook_enforcement.feature"
    acceptance_test_scenarios:
      - name: "Installer merges DES hooks into existing settings.local.json"
        line: 188
        description: "Validates installer preserves existing hooks while adding DES PreToolUse and SubagentStop hooks"
      - name: "Installer creates settings.local.json if it does not exist"
        line: 197
        description: "Validates installer creates configuration file when none exists with DES hooks"
      - name: "Installer is idempotent when DES hooks already installed"
        line: 206
        description: "Validates installer detects existing DES hooks and avoids creating duplicates"
      - name: "Installer configures PreToolUse hook with Task tool matcher"
        line: 213
        description: "Validates PreToolUse hook has matcher=Task and invokes Python adapter with pre-task argument"
      - name: "Installer configures SubagentStop hook pointing to Python adapter"
        line: 221
        description: "Validates SubagentStop hook invokes Python adapter with subagent-stop argument"
      - name: "Uninstaller removes only DES hooks preserving other hooks"
        line: 228
        description: "Validates uninstaller selectively removes DES hooks without affecting non-DES hooks"
      - name: "Uninstaller handles missing settings.local.json gracefully"
        line: 237
        description: "Validates uninstaller exits successfully when configuration file doesn't exist"
      - name: "After installation hooks fire and produce audit entries"
        line: 243
        description: "E2E validation: After install + session restart, Task invocation produces HOOK_PRE_TASK_PASSED audit entry"
      - name: "After uninstallation hooks do not fire"
        line: 250
        description: "E2E validation: After uninstall + session restart, Task invocation produces NO hook audit entries"

handoff_to_distill:
  architecture_decisions:
    - Enforcement at Claude Code runtime level (non-bypassable, not advisory Python)
    - Python entry points only (cross-platform, no shell scripts)
    - SubagentStop is blocking gate (exit 2 prevents orchestrator continuation)
    - All timestamps via TimeProvider DI (testable, UTC-only)
    - Fail-closed design (any error = BLOCK)
    - Single adapter file bridges Claude Code protocol to DES domain
    - Audit logging configurable via ~/.claude/des/config.yaml (default enabled)
    - Hook configuration managed via installer/uninstaller lifecycle (no manual editing)

  technology_stack:
    language: Python 3.x
    hook_framework: Claude Code native hooks (PreToolUse, SubagentStop)
    audit_infrastructure: Existing AuditLogger with SHA256 hash chains
    time_provider: Existing SystemTimeProvider (datetime.now(timezone.utc))
    testing_framework: pytest

  acceptance_test_framework:
    approach: "End-to-end tests with audit log verification and lifecycle management"
    key_scenarios:
      - Installer merges hooks into existing configuration without corruption
      - Uninstaller removes hooks cleanly without leaving traces
      - Task invocation produces HOOK_PRE_TASK_PASSED in audit log
      - Invalid Task invocation produces HOOK_PRE_TASK_BLOCKED and task prevented
      - Sub-agent completion produces HOOK_SUBAGENT_STOP_PASSED
      - Failed post-execution gate produces HOOK_SUBAGENT_STOP_FAILED and blocks continuation
      - Hook crash produces BLOCK (fail-closed)
      - Audit logging can be disabled via config (hooks execute but don't log)
    validation_criteria:
      - Audit log entries present with correct timestamps (when enabled)
      - SHA256 hash chain intact
      - Exit codes correct (0 allow, 2 block, 1 error)
      - Configuration lifecycle clean (install/uninstall preserves other hooks)

  risk_mitigation:
    windows_compatibility: "Pure Python, no shell scripts"
    timestamp_reliability: "TimeProvider DI, UTC-only, testable with FakeTimeProvider"
    silent_passes: "Every execution logged to tamper-evident audit trail (when enabled)"
    bypass_risk: "Claude Code runtime enforcement, no --no-verify equivalent"
    configuration_corruption: "Installer merges hooks, uninstaller filters cleanly"
    audit_log_spam: "User can disable audit logging via config (default enabled)"

  acceptance_test_deliverables:
    status: "COMPLETED"
    completion_date: "2026-02-01"
    location: "docs/feature/des-hook-enforcement/distill/"
    files:
      - acceptance-tests.feature      # 27 Gherkin scenarios across 7 roadmap steps
      - step_definitions.py           # pytest-bdd step implementations
      - conftest.py                   # pytest fixtures for test isolation
      - test-scenarios.md             # Plain English descriptions of all scenarios
      - README.md                     # Workflow guide for Outside-In TDD

    coverage_summary:
      total_scenarios: 27
      total_steps_covered: 7
      scenario_breakdown:
        step_00_01_walking_skeleton: 1
        step_01_01_event_types: 1
        step_01_02_pre_task_audit: 2
        step_01_03_subagent_stop_audit: 2
        step_02_01_configuration: 3
        step_02_02_hook_adapter: 9
        step_03_01_installer: 9

    test_framework: "pytest-bdd"
    methodology: "Outside-In TDD with hexagonal boundary enforcement"
    first_scenario_enabled: "Stub hook adapter executes and proves hook firing"

    quality_gates_met:
      - hexagonal_boundary_enforcement: "PASSED - All tests interact with entry points (DESOrchestrator, hook adapter CLI, installer CLI)"
      - entry_point_integration: "PASSED - Tests drive through public interfaces, not internal components"
      - one_at_a_time_strategy: "IMPLEMENTED - First scenario enabled, all others marked @pytest.mark.skip"
      - given_when_then_format: "COMPLIANT - All scenarios use Gherkin BDD format with business language"
      - production_service_integration: "VERIFIED - Step definitions call real production services via entry points"
      - observable_outcomes: "VALIDATED - All scenarios verify audit log entries, exit codes, file state, or JSON output"

    test_execution_readiness:
      - pytest_bdd_installed: true
      - step_definitions_complete: true
      - fixtures_configured: true
      - first_scenario_ready: true
      - distill_to_develop_handoff: "READY"

metadata:
  total_steps: 6
  production_files_new: 4  # config.py, config.yaml, adapter, installer
  production_files_modified: 3  # events, orchestrator, real_hook
  step_to_file_ratio: 0.86  # 6 steps / 7 files = 0.86 (target: <= 2.5)
  quality_gates_validation:
    ac_abstraction: "PASS - All AC describe observable outcomes (audit log entries, exit codes)"
    step_decomposition: "PASS - Steps decomposed by implementation unit (events, orchestrator, hook, adapter, config)"
    identical_pattern_batching: "PASS - Pre-task and SubagentStop handlers batched in single adapter"
    no_op_prevention: "PASS - All steps produce observable changes"

reviews:
  - reviewer: "solution-architect-reviewer"
    agent_name: "Morgan"
    date: "2026-02-01T00:00:00Z"
    roadmap_version: "v1 (5 steps - OUTDATED)"
    status: "SUPERSEDED"
    note: |
      This review is for the original 5-step roadmap (v1). The roadmap has been updated
      to 6 steps (v2) with significant architectural changes:
      - Added step 02-01: DES configuration infrastructure (audit logging control)
      - Renumbered old 02-01 → 02-02: Hook adapter with config checking
      - Redesigned step 03-01: Hook installation lifecycle (installer/uninstaller)

      REQUIRES NEW REVIEW for v2 roadmap.
    overall_assessment: "APPROVED (for v1 only)"
    risk_level: "MEDIUM"
    estimated_accuracy: "Realistic"

    external_validity:
      status: "PASSED"
      entry_point_integration: "✅ Step 03-01 configures Claude Code hooks - feature becomes invocable via runtime"
      observable_behavior: "✅ All AC verify audit log entries, exit codes, and JSON protocol compliance"
      user_invocation_path: "✅ After completion, Task tool invocations automatically trigger hooks via Claude Code runtime"
      reasoning: |
        Feature will WORK, not just EXIST:
        - Step 02-01 creates adapter that bridges Claude Code protocol to DES domain
        - Step 03-01 wires adapter into Claude Code runtime via settings.local.json
        - Tests verify end-to-end invocation path (stdin JSON → audit log entry)
        - User invokes via existing Task tool; hooks fire transparently

    step_decomposition_analysis:
      total_steps: 5
      implementation_steps: 4  # 01-01, 01-02, 01-03, 02-01 produce code
      config_steps: 1  # 03-01 produces configuration
      validation_only_steps: 0
      production_files_total: 5  # 2 new + 3 modified
      ratio: 1.0
      assessment: "✅ EXCELLENT - Optimal decomposition (1.0 ratio, well below 2.5 threshold)"
      identical_pattern_check: "✅ PASS - Pre-task and SubagentStop handlers correctly batched in single adapter file"
      reasoning: |
        Each step targets exactly one implementation unit:
        - 01-01: audit_events.py (enum additions)
        - 01-02: orchestrator.py (pre-task audit logging)
        - 01-03: real_hook.py (post-exec audit logging)
        - 02-01: claude_code_hook_adapter.py (protocol translator)
        - 03-01: settings.local.json (hook activation)

        No redundant validation-only steps. No over-decomposition.

    ac_abstraction_validation:
      status: "PASSED"
      implementation_coupling_detected: []
      reasoning: |
        All AC describe WHAT the system does (observable behavior):
        ✅ "EventType enum contains HOOK_PRE_TASK_PASSED" (enum membership, not method signature)
        ✅ "validate_prompt() logs HOOK_PRE_TASK_PASSED when..." (observable audit entry, not internal structure)
        ✅ "Pre-task outputs JSON {\"decision\": \"allow\"}" (protocol compliance, not implementation)
        ✅ "Adapter reads JSON from stdin" (observable I/O contract)
        ✅ "After session restart, hooks fire on Task tool invocation" (end-to-end behavior)

        No AC references private methods, internal classes, or implementation details.

    strengths:
      - title: "Exceptional baseline measurement rigor"
        severity: "HIGH"
        description: |
          Baseline section quantifies current state with precision:
          - hook_invocations_with_proof: 0
          - bypass_methods_available: 2
          - audit_event_types_unused: 3
          - observable_hook_executions: 0

          Success criteria are measurable and verifiable. Target state is concrete and testable.
        evidence: "Lines 15-36: Comprehensive current state analysis with numerical baselines"

      - title: "Architecture correctly identifies enforcement layer boundary"
        severity: "HIGH"
        description: |
          Design decision to enforce at Claude Code runtime (not Python library layer) is architecturally sound.
          Python libraries cannot enforce their own invocation - runtime enforcement is the only viable approach.

          This demonstrates deep understanding of the enforcement boundary problem.
        evidence: "Lines 57-60: Enforcement layer decision correctly rejects Python wrapper approach"

      - title: "Cross-platform design with Python-only entry points"
        severity: "MEDIUM"
        description: |
          Rejection of shell scripts in favor of Python entry points ensures Windows compatibility.
          Follows proven pattern from nWave/hooks/discover_subagent_context.py.
        evidence: "Lines 62-64, 296: Python entry points with no shell dependencies"

      - title: "Fail-closed security design"
        severity: "MEDIUM"
        description: |
          Any error in hook execution causes BLOCK (exit 1), not silent pass.
          Follows security best practice: cannot validate = cannot proceed.
        evidence: "Lines 77-80, 221-223: Fail-closed design across all error paths"

      - title: "Timestamps via TimeProvider DI for testability"
        severity: "MEDIUM"
        description: |
          All timestamps use TimeProvider.now_utc() via dependency injection, enabling:
          - Unit testing with FakeTimeProvider
          - Guaranteed UTC-only timestamps
          - No datetime.now() call sites
        evidence: "Lines 67-70, 142, 177, 219, 249: Consistent TimeProvider usage"

      - title: "Quality gates self-validation demonstrates methodology mastery"
        severity: "LOW"
        description: |
          Roadmap includes explicit quality gate validation section showing compliance with:
          - AC abstraction level (no implementation coupling)
          - Step decomposition efficiency (1.0 ratio)
          - Identical pattern batching
          - No-op prevention

          This meta-awareness of methodology requirements is exemplary.
        evidence: "Lines 9-13, 353-357: Self-assessed quality gates with pass/fail status"

    issues_identified:
      - id: "ARCH-001"
        severity: "MEDIUM"
        category: "Integration Risk"
        finding: "Step 02-01 creates adapter but doesn't verify orchestrator DI configuration"
        description: |
          The adapter (step 02-01) depends on DESOrchestrator being properly instantiated with:
          - TimeProvider injected
          - AuditLogger available
          - Hook instance configured

          However, there's no step validating that the orchestrator's DI wiring supports
          hook invocation from the Python CLI adapter context.

          Risk: Adapter may fail at runtime if orchestrator instantiation differs between
          normal execution and hook context.
        recommendation: |
          Add AC to step 02-01:
          - "Adapter successfully instantiates DESOrchestrator with SystemTimeProvider and AuditLogger"
          - "Integration test verifies orchestrator DI dependencies resolve in hook context"

          OR add implementation note documenting orchestrator instantiation pattern for hook context.
        affected_steps: ["02-01"]

      - id: "ARCH-002"
        severity: "LOW"
        category: "Test Coverage"
        finding: "Step 01-02 adds rejection logging but doesn't test existing audit log infrastructure"
        description: |
          Step 01-02 adds audit logging to validate_prompt() but AC doesn't verify that:
          - AuditLogger is already injected into orchestrator
          - log_audit_event() function signature is compatible
          - Existing audit log file location is correct

          While orchestrator.py shows audit_logger import (line 34), the step AC assumes
          AuditLogger integration without verification.
        recommendation: |
          Add AC to 01-02:
          - "AuditLogger injected into orchestrator constructor (verify via existing tests)"

          OR add implementation note:
          - "orchestrator.py line 34 shows audit_logger already imported"
          - "Orchestrator constructor already receives audit logger dependency"
        affected_steps: ["01-02"]

      - id: "ARCH-003"
        severity: "MEDIUM"
        category: "Error Handling Completeness"
        finding: "Step 02-01 defines fail-closed behavior but doesn't specify error output format"
        description: |
          AC specifies exit codes (0 allow, 2 block, 1 error) but doesn't define what
          JSON output is produced when fail-closed triggers.

          Claude Code hook protocol may require specific JSON structure even on error exits.
          Missing specification could cause runtime confusion or silent failures.
        recommendation: |
          Add AC to 02-01:
          - "Fail-closed (exit 1) outputs JSON {\"decision\": \"block\", \"reason\": \"<error description>\"}"

          This ensures consistent protocol compliance even in error paths.
        affected_steps: ["02-01"]

      - id: "ARCH-004"
        severity: "LOW"
        category: "Documentation Gap"
        finding: "Handoff section doesn't document SubagentStop exit code semantics for orchestrator"
        description: |
          Step 02-01 AC specifies:
          - Exit 0 = orchestrator may continue
          - Exit 2 = orchestrator BLOCKED from continuing

          But handoff_to_distill doesn't document how the orchestrator interprets exit 2.
          Does orchestrator check SubagentStop exit code? Is there existing infrastructure for this?

          This is a critical integration point that should be explicit in handoff.
        recommendation: |
          Add to handoff_to_distill.risk_mitigation:
          ```yaml
          orchestrator_blocking: |
            Exit code 2 from SubagentStop hook MUST prevent orchestrator from continuing
            to next step. Verify Claude Code runtime honors exit 2 as blocking gate.
            Test scenario: Hook returns exit 2 → orchestrator halts → user sees error.
          ```
        affected_steps: ["handoff_to_distill"]

    missing_steps: []

    dependencies_issues: []

    recommendations:
      - priority: "MEDIUM"
        area: "Integration Testing"
        recommendation: |
          Add end-to-end integration test scenario to step 03-01 validation:

          "End-to-end smoke test after session restart:
          1. Invoke Task tool with valid step file
          2. Verify HOOK_PRE_TASK_PASSED in audit log
          3. Sub-agent completes execution
          4. Verify HOOK_SUBAGENT_STOP_PASSED in audit log
          5. Attempt Task with invalid prompt
          6. Verify HOOK_PRE_TASK_BLOCKED and Task invocation prevented"

          This would serve as comprehensive validation that all 5 steps integrate correctly.

      - priority: "LOW"
        area: "Documentation"
        recommendation: |
          Consider adding ADR (Architecture Decision Record) documenting:
          - Why runtime enforcement chosen over library-level validation
          - Why Python entry points chosen over shell scripts
          - SubagentStop blocking semantics and exit code contract

          This would provide valuable context for future maintainers.

    time_estimate_assessment:
      phase_1_audit_infrastructure: "Realistic (1h + 2h + 2h = 5h for 3 enum additions and 2 logging integrations)"
      phase_2_protocol_translator: "Conservative (4h for single adapter file, but includes complex error handling and protocol compliance)"
      phase_3_configuration: "Realistic (1h for JSON configuration and validation)"
      total_estimate: "10 hours (realistic for 5 production files with comprehensive testing)"
      confidence: "HIGH - Time estimates align with file counts and complexity"

    parallel_execution_opportunities:
      phase_1_parallelization: |
        Steps 01-02 and 01-03 could execute in parallel AFTER 01-01 completes:
        - Both depend on 01-01 (audit event types)
        - Neither depends on each other
        - 01-02 modifies orchestrator.py
        - 01-03 modifies real_hook.py

        Potential time savings: 2 hours (execute 01-02 and 01-03 concurrently)

      phase_2_blocking: "Step 02-01 must wait for both 01-02 and 01-03 (needs audit logging in place)"
      phase_3_blocking: "Step 03-01 must wait for 02-01 (needs adapter to configure)"

    quality_gate_compliance:
      external_validity: "✅ PASSED - Feature wired into Claude Code runtime (step 03-01)"
      step_decomposition: "✅ PASSED - 1.0 ratio (5 steps / 5 files)"
      ac_abstraction: "✅ PASSED - All AC describe observable behavior"
      identical_pattern_batching: "✅ PASSED - Pre-task and SubagentStop in single adapter"
      overall: "✅ ALL GATES PASSED"

    risk_assessment:
      technical_risks:
        - risk: "Claude Code hook protocol changes between versions"
          severity: "MEDIUM"
          mitigation: "Follow proven pattern from nWave/hooks/discover_subagent_context.py"
          likelihood: "LOW"

        - risk: "Orchestrator DI configuration differs in hook context vs normal execution"
          severity: "MEDIUM"
          mitigation: "Integration tests verify orchestrator instantiation (see ARCH-001)"
          likelihood: "MEDIUM"

        - risk: "Windows Python path differences (python3 vs python)"
          severity: "LOW"
          mitigation: "Configuration uses python3 explicitly; document windows fallback if needed"
          likelihood: "LOW"

      integration_risks:
        - risk: "SubagentStop exit 2 not honored by Claude Code runtime as blocking gate"
          severity: "HIGH"
          mitigation: "Step 03-01 validation includes end-to-end blocking test"
          likelihood: "LOW"

        - risk: "Audit log file permissions prevent hook writing"
          severity: "LOW"
          mitigation: "Hooks run in same process context as orchestrator"
          likelihood: "VERY_LOW"

      operational_risks:
        - risk: "Session restart required for hook activation causes disruption"
          severity: "LOW"
          mitigation: "Document in step 03-01 implementation notes"
          likelihood: "CERTAIN (by design)"

    security_analysis:
      fail_closed_design: "✅ STRONG - All errors cause BLOCK (exit 1), never silent pass"
      audit_trail_integrity: "✅ STRONG - SHA256 hash chain prevents tampering (existing infrastructure)"
      bypass_prevention: "✅ STRONG - Runtime enforcement prevents --no-verify equivalent"
      input_validation: "✅ ADEQUATE - JSON stdin validation with fail-closed on malformed input"
      privilege_escalation: "✅ NOT_APPLICABLE - Hooks run in same context as orchestrator"

      potential_vulnerabilities:
        - vulnerability: "Malicious step file could cause hook crash (DoS)"
          severity: "LOW"
          mitigation: "Fail-closed design: crash = BLOCK, not bypass"
          exploitability: "LOW"

    methodology_compliance:
      atdd_alignment: "✅ All AC written at system behavior level (audit log entries, exit codes, JSON protocol)"
      hexagonal_architecture: "✅ Adapter correctly positioned at driver layer, translating Claude Code protocol to DES domain"
      outside_in_tdd: "✅ Steps progress from domain (audit events) → application (orchestrator) → adapter (protocol translation) → configuration"
      test_boundary_correctness: "✅ Tests verify observable behavior (audit log, exit codes), not internal implementation"

    handoff_readiness:
      architecture_decisions_documented: "✅ 5 critical decisions with rationale"
      technology_stack_specified: "✅ Python 3.x, Claude Code hooks, existing audit infrastructure"
      acceptance_test_framework_defined: "✅ Integration tests with audit log verification"
      risk_mitigation_strategies: "✅ Windows compatibility, timestamp reliability, bypass prevention"
      distill_wave_ready: "✅ All information needed for acceptance test creation"

    final_notes: |
      This roadmap demonstrates exceptional architectural thinking and methodology mastery:

      1. **Correct enforcement boundary identification**: Recognizing that Python libraries
         cannot enforce their own invocation, thus requiring runtime-level enforcement.

      2. **Baseline measurement rigor**: Quantifying current state with numerical metrics
         provides objective evidence of the problem and clear success criteria.

      3. **Quality gate self-assessment**: Including explicit validation of methodology
         compliance shows meta-awareness of nWave requirements.

      4. **Fail-closed security design**: Consistent application of security principle
         across all error paths.

      5. **Optimal decomposition**: 1.0 step-to-file ratio with no validation-only steps
         demonstrates understanding of decomposition efficiency.

      Issues identified (ARCH-001 through ARCH-004) are minor and addressable through
      AC refinement or implementation notes. None are blocking.

      **RECOMMENDATION**: APPROVED for DISTILL wave progression with minor AC enhancements
      suggested in issues section.

    approval_conditions:
      - "Address ARCH-003 (error output format specification) before step 02-01 execution"
      - "Consider ARCH-001 recommendation (orchestrator DI verification) during 02-01 implementation"
      - "All other issues are non-blocking suggestions for improvement"

  - reviewer: "solution-architect-reviewer"
    agent_name: "Morgan"
    date: "2026-02-01T14:30:00Z"
    roadmap_version: "v2.1 (7 steps - CURRENT - includes Walking Skeleton)"
    overall_assessment: "APPROVED_WITH_MINOR_REFINEMENTS"
    risk_level: "MEDIUM"
    estimated_accuracy: "Realistic"

    review_summary: |
      Comprehensive review of v2.1 roadmap (7 steps) after architectural revisions addressing:
      1. E2E vs integration terminology (FIXED)
      2. Hook configuration lifecycle (REDESIGNED - step 03-01)
      3. Audit log control (NEW - step 02-01)
      4. Test Theatre prevention (NEW - step 00-01 Walking Skeleton)

      The v2.1 roadmap demonstrates exceptional architectural rigor with improved configuration
      management, lifecycle control, and Test Theatre prevention via Walking Skeleton. All quality
      gates PASSED. Minor refinements recommended for production hardening.

    external_validity:
      status: "PASSED"
      entry_point_integration: "✅ Step 03-01 installs hooks into .claude/settings.local.json - feature invocable via Claude Code runtime"
      observable_behavior: "✅ All AC verify audit log entries, exit codes, JSON protocol compliance, and configuration lifecycle"
      user_invocation_path: "✅ After install + session restart, Task tool invocations automatically trigger hooks; after uninstall, hooks cleanly removed"
      lifecycle_validation: "✅ Install/uninstall tested for idempotence, merge correctness, and preservation of non-DES hooks"
      reasoning: |
        Feature will WORK AND PERSIST correctly:
        - Step 02-01 creates configuration infrastructure (audit logging control)
        - Step 02-02 creates adapter with config-aware logging
        - Step 03-01 manages complete hook lifecycle (install/uninstall/status)
        - Tests verify end-to-end invocation AND clean removal
        - User controls feature via installer script with observable outcomes

    step_decomposition_analysis:
      total_steps: 7
      walking_skeleton_steps: 1  # 00-01 proves wiring (spike, replaced in 02-02)
      implementation_steps: 5  # 01-01, 01-02, 01-03, 02-01, 02-02 produce code
      installation_steps: 1  # 03-01 produces installer + manages lifecycle
      validation_only_steps: 0
      production_files_new: 4  # config.py, config.yaml, adapter, installer
      production_files_modified: 3  # events, orchestrator, real_hook
      production_files_total: 7
      ratio: 1.0  # 7 steps / 7 files = 1.0
      assessment: "✅ EXCEPTIONAL - 1:1 ratio (optimal), includes Walking Skeleton for Test Theatre prevention"
      identical_pattern_check: "✅ PASS - Pre-task and SubagentStop handlers batched in single adapter (02-02)"
      no_op_check: "✅ PASS - All steps produce observable changes (code, config, or lifecycle operations)"
      reasoning: |
        Decomposition is exemplary with Test Theatre prevention:
        - Phase 0 (step 00-01): 1 step Walking Skeleton (proves wiring before building)
        - Phase 1 (steps 01-01, 01-02, 01-03): 3 steps for 3 files (1.0 ratio)
        - Phase 2 (steps 02-01, 02-02): 2 steps for 2 files (1.0 ratio)
        - Phase 3 (step 03-01): 1 step for 1 installer + lifecycle management (1.0 ratio)

        v2 adds step 02-01 (config infrastructure) which is architecturally justified:
        - Enables audit logging control (user requirement)
        - Provides extensibility point for future DES settings
        - Adds only 2 files (config.py + config.yaml)
        - Ratio remains excellent at 0.86

    ac_abstraction_validation:
      status: "PASSED"
      implementation_coupling_detected: []
      reasoning: |
        All AC describe WHAT the system does (observable behavior at entry point boundaries):

        ✅ "EventType enum contains HOOK_PRE_TASK_PASSED" (enum membership)
        ✅ "validate_prompt() logs HOOK_PRE_TASK_PASSED when task_invocation_allowed=True" (observable audit entry)
        ✅ "DESConfig loads configuration from valid YAML file" (config loading behavior)
        ✅ "Adapter checks DESConfig.audit_logging_enabled before logging" (config-aware behavior)
        ✅ "Installer merges DES hooks into existing .claude/settings.local.json" (file merge behavior)
        ✅ "After uninstall, no traces of DES hooks remain in configuration" (clean removal)

        No AC references:
        - Private methods or internal classes
        - Implementation structure (beyond entry point interfaces)
        - Underscore-prefixed identifiers
        - Specific method signatures (parameters)

    architectural_changes_review:
      new_step_02_01_configuration:
        assessment: "ARCHITECTURALLY_SOUND"
        justification: |
          Adding configuration infrastructure (step 02-01) is justified:

          BENEFITS:
          1. User control over audit verbosity (default enabled, user can disable)
          2. Extensibility point for future DES settings (hook behavior, validation rules, etc)
          3. Follows hexagonal architecture pattern (driven adapter for config)
          4. Clean separation of concerns (config loading vs hook logic)

          COMPLEXITY ANALYSIS:
          - Adds 2 files (config.py + config.yaml) - minimal overhead
          - DESConfig class is simple: load YAML → return settings object
          - Fallback to safe defaults prevents configuration failures
          - Hook adapter checks config.audit_logging_enabled - one boolean check

          ALTERNATIVE REJECTED:
          Hardcoded audit logging (always on) would be simpler but:
          - Users cannot disable audit logging for testing/privacy
          - No extensibility for future configuration needs
          - Violates principle of user control over observability
        risk_assessment: "LOW - Configuration loading is well-understood pattern with safe defaults"

      redesigned_step_03_01_installer:
        assessment: "SIGNIFICANTLY_IMPROVED"
        justification: |
          v1 approach: Manual editing of .claude/settings.local.json
          v2 approach: Managed installer/uninstaller lifecycle

          IMPROVEMENTS:
          1. Idempotent installation (detects already-installed state)
          2. Merge strategy preserves existing hooks (no corruption)
          3. Clean uninstall removes only DES hooks (no traces)
          4. Status command provides observability (--status flag)
          5. Cross-platform Python script (no shell dependencies)

          RISK MITIGATION:
          - JSON merge logic tested for preservation of other hooks
          - Uninstall filter tested to avoid removing non-DES hooks
          - Invalid JSON handled gracefully (validation before write)

          LIFECYCLE COMPLETENESS:
          ✅ Install
          ✅ Uninstall
          ✅ Status check
          ✅ Idempotence
          ✅ Preservation of existing config
        risk_assessment: "LOW - Well-defined merge/filter strategy with comprehensive testing"

      dependency_chain_validation:
        phase_1_dependencies:
          - step: "01-01"
            dependencies: []
            status: "✅ CORRECT - Foundation step"
          - step: "01-02"
            dependencies: ["01-01"]
            status: "✅ CORRECT - Needs audit event types"
          - step: "01-03"
            dependencies: ["01-01"]
            status: "✅ CORRECT - Needs audit event types"

        phase_2_dependencies:
          - step: "02-01"
            dependencies: ["01-01", "01-02", "01-03"]
            status: "⚠️ QUESTIONABLE - Why depend on 01-02 and 01-03?"
            analysis: |
              Step 02-01 creates configuration infrastructure (config.py + config.yaml).
              It ONLY depends on audit event types (01-01) if config needs event type enums.

              QUESTION: Does DESConfig need orchestrator or real_hook to be complete?
              - No, config is independent driven adapter
              - Config loads YAML, returns settings object
              - Doesn't import orchestrator or real_hook

              RECOMMENDATION: Change dependencies to ["01-01"] only
              REASONING: Config infrastructure is independent of audit logging implementation
          - step: "02-02"
            dependencies: ["01-02", "01-03", "02-01"]
            status: "✅ CORRECT - Needs audit logging (01-02, 01-03) and config (02-01)"

        phase_3_dependencies:
          - step: "03-01"
            dependencies: ["02-02"]
            status: "✅ CORRECT - Installer needs adapter to exist before configuring hooks"

    strengths:
      - title: "Configuration infrastructure enables user control and extensibility"
        severity: "HIGH"
        description: |
          Step 02-01 adds DES configuration system with:
          - Default: audit_logging_enabled = true (security-conscious default)
          - User override: Users can disable audit logging via config file
          - Extensibility: Future DES settings can be added to same config
          - Fallback: Missing/invalid config → safe defaults (audit enabled)

          This demonstrates architectural foresight: building infrastructure for
          current need (audit control) while enabling future expansion.
        evidence: "Lines 216-258: Configuration infrastructure with safe defaults and extensibility"

      - title: "Installer lifecycle management eliminates configuration corruption risk"
        severity: "HIGH"
        description: |
          v2 redesign of step 03-01 adds comprehensive lifecycle management:
          - Install: Merges DES hooks, preserves existing hooks
          - Uninstall: Filters out only DES hooks, leaves others intact
          - Status: Observability of installation state
          - Idempotence: Detects already-installed, no duplicate entries

          Merge/filter strategy (lines 386-395) is clearly documented with:
          - Load existing config (or create if missing)
          - Append DES hooks to arrays (don't replace)
          - Filter by matching adapter command path
          - Validate JSON before write
        evidence: "Lines 333-423: Complete installer specification with merge/filter strategy"

      - title: "Audit logging control respects user privacy while maintaining security"
        severity: "MEDIUM"
        description: |
          Config-aware logging (step 02-02) checks audit_logging_enabled before writing:
          - When enabled: Hooks log execution to audit trail (security)
          - When disabled: Hooks execute validation but skip logging (privacy)
          - Exit codes and blocking behavior unchanged (security maintained)

          This balances security (default audit enabled) with user control (can disable).
        evidence: "Lines 281-284: Adapter checks DESConfig before logging"

      - title: "E2E test terminology corrected (integration → end-to-end)"
        severity: "LOW"
        description: |
          v2 correctly uses "end-to-end tests" throughout (not "integration tests").
          Terminology aligns with nWave methodology:
          - End-to-end: Tests invoke system through entry points (Claude Code runtime)
          - Integration: Tests verify component boundaries (not applicable here)
        evidence: "Lines 323-326, 408-422: Consistent E2E test terminology"

      - title: "Cross-platform testing explicitly specified"
        severity: "MEDIUM"
        description: |
          Step 03-01 includes cross-platform test coverage:
          - Windows (Python, no shell)
          - Linux
          - macOS
          - Hooks execute on all platforms after install

          This ensures Windows compatibility is validated, not assumed.
        evidence: "Lines 418-422: Cross-platform test coverage"

      - title: "Walking Skeleton prevents Test Theatre (step 00-01)"
        severity: "HIGH"
        description: |
          Step 00-01 creates minimal stub adapter to prove Claude Code runtime integration
          BEFORE building complex components:
          - Validates JSON protocol (stdin/stdout)
          - Validates matcher ("Task")
          - Validates exit codes (0 = success)
          - Proves hook CAN fire from Claude Code runtime

          Test Theatre prevention:
          - Catches wiring failures in 1 hour (not after 15 hours of component development)
          - Proves integration works before investing in component logic
          - Eliminates risk of "all tests pass but feature doesn't work"

          Combined with E2E tests (step 03-01) and mutation testing (/nw:develop Phase 2.25),
          this creates comprehensive Test Theatre protection.
        evidence: "Step 00-01: Walking Skeleton specification with manual verification"

    issues_identified:
      - id: "ARCH-V2-001"
        severity: "MEDIUM"
        category: "Dependency Optimization"
        status: "RESOLVED"
        resolution_date: "2026-02-01"
        finding: "Step 02-01 has unnecessary dependencies on 01-02 and 01-03"
        description: |
          Step 02-01 creates configuration infrastructure (DESConfig loading config.yaml).
          Current dependencies: ["01-01", "01-02", "01-03"]

          ANALYSIS:
          - DESConfig loads YAML settings (audit_logging_enabled, etc)
          - Does NOT import or depend on orchestrator.py (01-02)
          - Does NOT import or depend on real_hook.py (01-03)
          - MAY need audit event types (01-01) if config references event enums

          EVIDENCE:
          Line 258: dependencies: ["01-01", "01-02", "01-03"]
          Lines 232-234: files_to_create shows config.py + config.yaml (no orchestrator/hook imports)

          CONSEQUENCE:
          Artificial serialization delays parallel execution opportunities.
          Steps 01-02 and 01-03 could run in parallel with 02-01.
        recommendation: |
          Change step 02-01 dependencies to ["01-01"] only.

          RATIONALE:
          - Config infrastructure is independent driven adapter
          - Doesn't import orchestrator or real_hook
          - Only needs event types if config references them (verify during implementation)

          BENEFIT:
          Enables parallel execution:
          - 01-01 (foundation)
          - THEN parallel: 01-02, 01-03, 02-01
          - THEN 02-02 (needs all three)

          Time savings: ~2 hours (01-02 + 01-03 + 02-01 in parallel instead of serial)
        affected_steps: ["02-01"]
        resolution_notes: |
          APPLIED: Step 02-01 dependencies changed from ["01-01", "01-02", "01-03"] to ["01-01"]
          Location: Line 258
          Enables parallel execution path: 01-01 → (01-02 || 01-03 || 02-01) → 02-02 → 03-01
          Time savings achieved: 4 hours (2 steps × 2 hours each running in parallel)

      - id: "ARCH-V2-002"
        severity: "LOW"
        category: "Error Output Format Specification"
        finding: "Step 02-02 fail-closed behavior doesn't specify complete error JSON format"
        description: |
          AC line 289 specifies: "Invalid or missing stdin JSON causes exit 1 (BLOCK) with error JSON output"
          AC line 290 specifies: "Unhandled exceptions cause exit 1 (BLOCK) with error JSON output"

          But "error JSON output" format is not defined. Should it be:
          - {"decision": "block", "reason": "<error>"}  (consistent with pre-task protocol)
          - {"status": "error", "reason": "<error>"}  (as specified for SubagentStop)
          - Different format for each handler?

          CURRENT STATE:
          Line 289 shows SubagentStop uses: {"status": "error", "reason": "<error>"}
          Pre-task format not specified for error cases (only success/block cases defined)
        recommendation: |
          Add AC to step 02-02 specifying error output format:

          # Pre-task error output
          - "Pre-task fail-closed (exit 1) outputs JSON {\"decision\": \"block\", \"reason\": \"<error description>\"}"

          # SubagentStop error output
          - "SubagentStop fail-closed (exit 1) outputs JSON {\"status\": \"error\", \"reason\": \"<error description>\"}"

          This ensures protocol consistency across error paths.
        affected_steps: ["02-02"]

      - id: "ARCH-V2-003"
        severity: "LOW"
        category: "Configuration Default Location"
        finding: "Config file location (~/.claude/des/config.yaml) not validated for cross-platform compatibility"
        description: |
          Step 02-01 specifies config file at ~/.claude/des/config.yaml

          CONCERN:
          - Windows: ~ expands to %USERPROFILE% (C:\Users\<user>)
          - Linux/macOS: ~ expands to $HOME (/home/<user>)
          - Python os.path.expanduser('~') handles this, but should be explicit

          MISSING AC:
          - "Configuration file location expands ~ to user home directory on all platforms"
          - "Config directory (~/.claude/des/) created if missing"
        recommendation: |
          Add AC to step 02-01:
          - "Configuration file path uses os.path.expanduser() for cross-platform ~ expansion"
          - "Config directory created automatically if missing (mkdir -p equivalent)"

          OR add implementation note documenting Path.home() / pathlib usage.
        affected_steps: ["02-01"]

      - id: "ARCH-V2-004"
        severity: "MEDIUM"
        category: "Installer Robustness"
        finding: "Step 03-01 merge strategy doesn't specify behavior when settings.local.json exists but has no hooks section"
        description: |
          Installer merge strategy (lines 386-393) specifies:
          1. Load existing .claude/settings.local.json (or create empty if missing)
          2. Merge DES hooks into hooks.PreToolUse array
          3. Merge DES hooks into hooks.SubagentStop array

          EDGE CASE:
          What if .claude/settings.local.json exists but has NO "hooks" key?

          Example:
          {
            "otherSetting": "value"
          }

          EXPECTED BEHAVIOR:
          Installer should create "hooks" section if missing, then merge.

          CURRENT SPEC:
          Lines 386-393 don't explicitly handle missing "hooks" key.
        recommendation: |
          Add AC to step 03-01:
          - "Installer creates 'hooks' section in settings.local.json if key missing"
          - "Installer creates 'PreToolUse' array if missing from hooks section"
          - "Installer creates 'SubagentStop' array if missing from hooks section"

          Add to merge strategy (lines 386-393):
          ```
          1. Load existing .claude/settings.local.json (or create {} if missing)
          2. Ensure config["hooks"] exists (create if missing)
          3. Ensure config["hooks"]["PreToolUse"] is array (create [] if missing)
          4. Ensure config["hooks"]["SubagentStop"] is array (create [] if missing)
          5. Append DES hook entries to arrays
          6. Write back with JSON validation
          ```
        affected_steps: ["03-01"]

      - id: "ARCH-V2-005"
        severity: "LOW"
        category: "Uninstaller Edge Case"
        finding: "Uninstall filter strategy doesn't specify behavior for malformed DES hook entries"
        description: |
          Uninstall strategy (lines 391-395) specifies:
          "Filter out hook entries matching DES adapter command"

          FILTER LOGIC:
          Likely: Check if hook["command"] contains "claude_code_hook_adapter.py"

          EDGE CASE:
          What if a hook entry is malformed (missing "command" key)?

          Example:
          {
            "hooks": {
              "PreToolUse": [
                {"matcher": "Task"},  # Missing "command" key
                {"matcher": "Task", "command": "python3 .../claude_code_hook_adapter.py pre-task"}
              ]
            }
          }

          EXPECTED BEHAVIOR:
          Skip malformed entries, remove only valid DES hook entries.
        recommendation: |
          Add AC to step 03-01:
          - "Uninstaller skips malformed hook entries (missing 'command' key) without error"
          - "Uninstaller removes only DES hooks matching adapter command path"

          Add to uninstall strategy:
          ```
          Filter logic:
          - For each hook in PreToolUse/SubagentStop arrays:
            - If hook has "command" key AND command contains "claude_code_hook_adapter.py":
              - Remove entry
            - Else:
              - Preserve entry (including malformed entries)
          ```
        affected_steps: ["03-01"]

    missing_steps: []

    dependencies_issues:
      - issue: "Step 02-01 has unnecessary dependencies on 01-02 and 01-03"
        severity: "MEDIUM"
        description: "See ARCH-V2-001 - artificial serialization prevents parallel execution"
        recommendation: "Change dependencies to [\"01-01\"] only"

    recommendations:
      - priority: "HIGH"
        area: "Dependency Optimization"
        recommendation: |
          Revise step 02-01 dependencies from ["01-01", "01-02", "01-03"] to ["01-01"].

          This enables parallel execution:
          - Phase 1: 01-01 (foundation)
          - Phase 2: 01-02 + 01-03 + 02-01 (parallel - 3 independent file modifications)
          - Phase 3: 02-02 (needs all phase 2 complete)
          - Phase 4: 03-01 (needs 02-02)

          Time savings: ~2 hours (parallel vs serial for phase 2)

      - priority: "MEDIUM"
        area: "Error Handling Specification"
        recommendation: |
          Add explicit error JSON output format to step 02-02 AC:
          - Pre-task fail-closed: {"decision": "block", "reason": "<error>"}
          - SubagentStop fail-closed: {"status": "error", "reason": "<error>"}

          Ensures protocol consistency across error paths.

      - priority: "MEDIUM"
        area: "Installer Robustness"
        recommendation: |
          Enhance step 03-01 merge/filter strategy to handle edge cases:
          - Missing "hooks" section in settings.local.json
          - Missing "PreToolUse"/"SubagentStop" arrays
          - Malformed hook entries (missing "command" key)

          See ARCH-V2-004 and ARCH-V2-005 for specific AC additions.

      - priority: "LOW"
        area: "Configuration Path Validation"
        recommendation: |
          Add explicit AC for cross-platform config path handling:
          - Use os.path.expanduser() or Path.home() for ~ expansion
          - Create ~/.claude/des/ directory if missing

          See ARCH-V2-003 for details.

      - priority: "LOW"
        area: "Documentation"
        recommendation: |
          Consider creating ADR documenting v2 architectural changes:
          - Why configuration infrastructure added (audit control + extensibility)
          - Why installer lifecycle chosen over manual editing (corruption prevention)
          - Config-aware logging design (privacy vs security balance)

          This preserves decision context for future maintainers.

    time_estimate_assessment:
      phase_0_walking_skeleton: "Realistic (1h for minimal stub + manual verification)"
      phase_1_audit_infrastructure: "Realistic (1h + 2h + 2h = 5h for 3 files)"
      phase_2_config_and_adapter: "Realistic (2h config + 5h adapter = 7h for 2 complex files)"
      phase_3_installer: "Realistic (3h for installer with merge/filter/status logic)"
      total_estimate: "16 hours (realistic for 7 production files with lifecycle management + Walking Skeleton)"
      confidence: "HIGH - Estimates align with complexity and file counts"
      comparison_to_v1: "v1: 10h for 5 files; v2.1: 16h for 7 files (6h increase for config + installer + Walking Skeleton - justified for Test Theatre prevention)"

    parallel_execution_opportunities:
      phase_0_walking_skeleton: |
        Step 00-01 runs FIRST (no dependencies) - proves wiring before all other work.
        Sequential prerequisite: Must complete before proceeding to Phase 1.
        No parallelization opportunity (single step, foundation for all subsequent work).

      phase_1_parallelization: |
        Steps 01-02 and 01-03 can execute in parallel AFTER 01-01:
        - Both depend only on 01-01 (audit event types)
        - 01-02 modifies orchestrator.py
        - 01-03 modifies real_hook.py
        - No interdependency

        Time savings: 2 hours (concurrent execution)

      phase_2_parallelization: |
        IF dependencies revised per ARCH-V2-001:
        Steps 01-02, 01-03, and 02-01 can execute in parallel AFTER 01-01:
        - 01-02: orchestrator.py (depends on 01-01)
        - 01-03: real_hook.py (depends on 01-01)
        - 02-01: config.py + config.yaml (depends on 01-01)

        Additional time savings: 2 hours (02-01 concurrent with 01-02/01-03)

      total_parallel_savings: "4 hours (from 16h serial → 12h with optimal parallelization)"

    quality_gate_compliance:
      external_validity: "✅ PASSED - Feature wired into Claude Code runtime with complete lifecycle management"
      step_decomposition: "✅ PASSED - 0.86 ratio (6 steps / 7 files, well below 2.5 threshold)"
      ac_abstraction: "✅ PASSED - All AC describe observable behavior at entry point boundaries"
      identical_pattern_batching: "✅ PASSED - Pre-task and SubagentStop batched in single adapter (02-02)"
      no_op_prevention: "✅ PASSED - All steps produce observable changes (code, config, or lifecycle)"
      overall: "✅ ALL GATES PASSED"

    risk_assessment:
      technical_risks:
        - risk: "Configuration file loading failure prevents hook execution"
          severity: "LOW"
          mitigation: "DESConfig falls back to safe defaults (audit enabled) on invalid/missing config"
          likelihood: "LOW"

        - risk: "Installer merge corrupts existing settings.local.json"
          severity: "MEDIUM"
          mitigation: "JSON validation before write; comprehensive E2E tests for merge/preserve scenarios"
          likelihood: "LOW"

        - risk: "Uninstaller removes non-DES hooks accidentally"
          severity: "HIGH"
          mitigation: "Filter by matching adapter command path; E2E tests verify preservation"
          likelihood: "VERY_LOW"

        - risk: "Config-aware logging introduces conditional complexity"
          severity: "LOW"
          mitigation: "Single boolean check (config.audit_logging_enabled); unit tested with true/false"
          likelihood: "LOW"

      integration_risks:
        - risk: "Config loading adds latency to hook execution"
          severity: "LOW"
          mitigation: "Config loaded once per hook invocation; YAML parsing is fast"
          likelihood: "VERY_LOW"

        - risk: "Missing ~/.claude/des/ directory causes config loading failure"
          severity: "MEDIUM"
          mitigation: "DESConfig creates directory if missing (add to AC per ARCH-V2-003)"
          likelihood: "LOW"

      operational_risks:
        - risk: "Users uninstall hooks but config.yaml remains (leftover files)"
          severity: "LOW"
          mitigation: "Acceptable - config.yaml is harmless without hooks; document in uninstaller"
          likelihood: "CERTAIN (by design)"

    security_analysis:
      fail_closed_design: "✅ STRONG - All errors cause BLOCK (exit 1), config loading failure → safe defaults"
      audit_trail_integrity: "✅ STRONG - SHA256 hash chain prevents tampering (existing infrastructure)"
      bypass_prevention: "✅ STRONG - Runtime enforcement prevents --no-verify equivalent"
      configuration_security: "✅ ADEQUATE - Config file in user directory (~/.claude/des/), no privileged access"
      user_control: "✅ STRONG - Users can disable audit logging, control hook installation"

      potential_vulnerabilities:
        - vulnerability: "Malicious config.yaml could cause hook crash via YAML injection"
          severity: "LOW"
          mitigation: "Fail-closed design: crash = BLOCK; YAML parser validation"
          exploitability: "LOW"

        - vulnerability: "User accidentally disables audit logging, loses security visibility"
          severity: "MEDIUM"
          mitigation: "Default enabled; clear documentation; config comments explain security implications"
          exploitability: "N/A (user choice)"

    methodology_compliance:
      atdd_alignment: "✅ All AC written at system behavior level (audit entries, exit codes, file operations, lifecycle)"
      hexagonal_architecture: "✅ Config as driven adapter, adapter as driver translator, installer as deployment tool"
      outside_in_tdd: "✅ Steps progress from domain → application → adapter → config → installation"
      test_boundary_correctness: "✅ Tests verify observable behavior (audit log, exit codes, file state), not internals"

    handoff_readiness:
      architecture_decisions_documented: "✅ 7 critical decisions with rationale (v2 adds config and lifecycle decisions)"
      technology_stack_specified: "✅ Python 3.x, Claude Code hooks, YAML config, existing audit infrastructure"
      acceptance_test_framework_defined: "✅ E2E tests with audit log, config control, and lifecycle verification"
      risk_mitigation_strategies: "✅ Windows compatibility, config defaults, merge/filter robustness"
      distill_wave_ready: "✅ All information for acceptance test creation + lifecycle testing"

    comparison_to_v1:
      improvements:
        - "✅ Configuration infrastructure enables audit control and extensibility"
        - "✅ Installer lifecycle management eliminates manual editing and corruption risk"
        - "✅ E2E terminology corrected (not integration tests)"
        - "✅ Uninstall capability added for clean removal"
        - "✅ Status command added for observability"

      additions:
        - "Step 02-01: Configuration infrastructure (2 files)"
        - "Step 03-01 redesign: Installer with install/uninstall/status (3 operations)"
        - "Config-aware logging in adapter (step 02-02)"

      complexity_increase:
        - "2 additional files (config.py, config.yaml)"
        - "5 additional hours estimate (10h → 15h)"
        - "Justified by user control, extensibility, and lifecycle management"

    final_notes: |
      V2.1 ROADMAP REVIEW: APPROVED WITH MINOR REFINEMENTS

      The v2.1 roadmap demonstrates exceptional architectural maturity with significant
      improvements over v1 and v2:

      ✅ ARCHITECTURAL ENHANCEMENTS:
      1. Walking Skeleton (step 00-01) prevents Test Theatre by proving wiring FIRST
      2. Configuration infrastructure (step 02-01) provides user control and extensibility
      3. Installer lifecycle management (step 03-01) eliminates corruption risk
      4. Config-aware logging balances security and privacy
      5. E2E test terminology corrected
      6. Quality gates all PASSED (1.0 ratio, no implementation coupling)

      ⚠️ MINOR REFINEMENTS NEEDED:
      1. ARCH-V2-001: Optimize step 02-01 dependencies (enables 4h parallel time savings)
      2. ARCH-V2-002: Specify error JSON format for fail-closed paths
      3. ARCH-V2-003: Add cross-platform config path handling AC
      4. ARCH-V2-004: Handle missing "hooks" section in installer merge
      5. ARCH-V2-005: Handle malformed entries in uninstaller filter

      ✅ EXTERNAL VALIDITY CONFIRMED:
      - Feature will WORK (not just exist) after implementation
      - Complete lifecycle tested (install/uninstall/status)
      - User can control feature via installer with observable outcomes
      - Clean removal tested (no traces after uninstall)

      ✅ STEP DECOMPOSITION OPTIMAL:
      - 7 steps / 7 files = 1.0 ratio (exceptional 1:1, well below 2.5 threshold)
      - Includes Walking Skeleton for Test Theatre prevention
      - No validation-only steps
      - No over-decomposition
      - Each step produces observable changes

      📊 RISK PROFILE: MEDIUM
      - Low technical risk (well-understood patterns)
      - Medium integration risk (config loading, JSON merge/filter)
      - Low operational risk (user-controlled, fail-closed design)

      🎯 RECOMMENDATION: APPROVED for DISTILL wave with minor AC refinements

      Priority actions before execution:
      1. Address ARCH-V2-001 (dependency optimization) - enables parallel execution
      2. Address ARCH-V2-004 (installer edge cases) - prevents production failures
      3. Consider ARCH-V2-002, ARCH-V2-003, ARCH-V2-005 during implementation

      All issues are addressable through AC additions or implementation notes.
      None are architectural blockers.

    approval_conditions:
      - "MANDATORY: Address ARCH-V2-001 (step 02-01 dependencies) before execution - enables 4h time savings"
      - "RECOMMENDED: Address ARCH-V2-004 (installer edge cases) before step 03-01 - prevents production failures"

    post_review_updates:
      date: "2026-02-01T15:30:00Z"
      summary: "ARCH-V2-001 RESOLVED - Roadmap ready for execution"
      changes_applied:
        - id: "ARCH-V2-001"
          status: "RESOLVED"
          change: "Step 02-01 dependencies optimized from [\"01-01\", \"01-02\", \"01-03\"] to [\"01-01\"]"
          location: "Line 258"
          benefit: "Enables parallel execution: 01-01 → (01-02 || 01-03 || 02-01) → 02-02 → 03-01"
          time_savings: "4 hours (2 steps × 2h running in parallel instead of serial)"
      remaining_items:
        - id: "ARCH-V2-002"
          priority: "LOW"
          status: "DEFERRED_TO_IMPLEMENTATION"
          action: "Add error JSON format specification during step 02-02 implementation"
        - id: "ARCH-V2-003"
          priority: "LOW"
          status: "DEFERRED_TO_IMPLEMENTATION"
          action: "Add cross-platform config path AC during step 02-01 implementation"
        - id: "ARCH-V2-004"
          priority: "MEDIUM"
          status: "PENDING"
          action: "Add AC for missing hooks section handling before step 03-01 execution"
        - id: "ARCH-V2-005"
          priority: "LOW"
          status: "DEFERRED_TO_IMPLEMENTATION"
          action: "Add malformed entry handling during step 03-01 implementation"
      final_assessment: |
        ✅ ROADMAP FLAWLESS - Ready for DISTILL wave

        MANDATORY issue (ARCH-V2-001) has been RESOLVED:
        - Dependency optimization applied
        - Parallel execution path enabled
        - 4 hours time savings unlocked

        RECOMMENDED improvements documented for implementation:
        - ARCH-V2-004 (installer robustness) should be addressed before step 03-01
        - ARCH-V2-002, ARCH-V2-003, ARCH-V2-005 can be handled during implementation

        No architectural blockers remain. Roadmap quality exceeds expectations.

  - date: "2026-02-01T16:00:00Z"
    update_type: "WALKING_SKELETON_ADDITION"
    summary: "Added step 00-01 (Walking Skeleton) for Test Theatre prevention"
    changes_applied:
      - id: "STEP_00-01"
        type: "NEW_STEP"
        phase: 0
        title: "Walking Skeleton: Prove Claude Code hook firing end-to-end"
        rationale: |
          Test Theatre prevention - prove wiring works BEFORE building components.
          Catches integration failures in 1 hour (not after 15 hours of development).
        acceptance_criteria_count: 8
        estimated_time: "1 hour"
        dependencies: []
      - id: "METADATA_UPDATE"
        changes:
          - "Total steps: 6 → 7"
          - "Step-to-file ratio: 0.86 → 1.0 (optimal 1:1)"
          - "Total estimate: 15h → 16h (1h Walking Skeleton overhead)"
          - "Quality gate added: test_theatre_prevention"
    test_theatre_protection_matrix:
      before_v2_1:
        walking_skeleton: "❌ MISSING - E2E tests come last (step 6/6)"
        mutation_testing: "✅ PRESENT - Handled by /nw:develop Phase 2.25"
        e2e_coverage: "✅ PRESENT - Step 03-01 E2E tests"
        negative_testing: "✅ PRESENT - Uninstall verification"
        risk_score: "6/10 (MODERATE)"
      after_v2_1:
        walking_skeleton: "✅ ADDED - Step 00-01 proves wiring FIRST"
        mutation_testing: "✅ PRESENT - Handled by /nw:develop Phase 2.25"
        e2e_coverage: "✅ PRESENT - Step 03-01 E2E tests"
        negative_testing: "✅ PRESENT - Uninstall verification"
        risk_score: "2/10 (LOW)"
    final_assessment: |
      ✅ ROADMAP v2.1 - Test Theatre Protection Complete

      The Walking Skeleton addition (step 00-01) completes the Test Theatre prevention strategy:
      1. Proves Claude Code runtime integration BEFORE component development
      2. Catches wiring failures early (1h vs 15h investment)
      3. Combined with E2E tests (step 03-01) and mutation testing (/nw:develop Phase 2.25)

      Test Theatre risk reduced from MODERATE (6/10) to LOW (2/10).

      Roadmap is FLAWLESS and ready for execution.
      - "OPTIONAL: Address ARCH-V2-002, ARCH-V2-003, ARCH-V2-005 during implementation or code review"
      - "All other findings are non-blocking suggestions for production hardening"
