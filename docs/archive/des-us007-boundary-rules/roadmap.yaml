# Implementation Roadmap: DES US-007 Boundary Rules for Scope Enforcement
# Feature: Prevent agent scope creep with explicit ALLOWED/FORBIDDEN action definitions
# Created: 2026-01-29
# Acceptance Tests: tests/des/acceptance/test_us007_boundary_rules.py (14 scenarios)
# Schema Version: 2.0 (enhanced with execution context for step-less workflow)

project_id: des-us007-boundary-rules
schema_version: "2.0"
created_at: '2026-01-29T00:00:00Z'
methodology: Outside-In TDD
total_scenarios: 14
total_phases: 4

# TDD Phase Definitions (from canonical schema - loaded once by orchestrator)
tdd_phases:
  - index: 0
    name: "PREPARE"
    description: "Remove @skip decorators, verify only 1 scenario enabled"
  - index: 1
    name: "RED_ACCEPTANCE"
    description: "Run acceptance test, expect FAIL for valid reason"
  - index: 2
    name: "RED_UNIT"
    description: "Write failing unit tests before implementation"
  - index: 3
    name: "GREEN"
    description: "Implement minimum code to pass all tests (unit + acceptance)"
  - index: 4
    name: "REVIEW"
    description: "Quality review: SOLID, coverage, criteria, refactoring quality"
  - index: 5
    name: "REFACTOR_CONTINUOUS"
    description: "Progressive refactoring: L1 (naming) + L2 (complexity) + L3 (organization)"
  - index: 6
    name: "REFACTOR_L4"
    description: "Architecture patterns (OPTIONAL - can use CHECKPOINT_PENDING or NOT_APPLICABLE)"
  - index: 7
    name: "COMMIT"
    description: "Final validate + commit with detailed message (absorbs FINAL_VALIDATE)"

# Execution Configuration (orchestrator settings)
execution_config:
  max_turns_per_phase: 50
  timeout_thresholds: [30, 60, 90]
  timeout_budget_minutes: 120

# ============================================================================
# ROADMAP OVERVIEW
# ============================================================================
#
# This roadmap implements boundary rules enforcement through 4 phases:
#
# PHASE 1: Template Foundation (3 steps)
#   - Build BOUNDARY_RULES template rendering infrastructure
#   - Make scenarios 001, 012, 013 pass (section presence and structure)
#
# PHASE 2: Scope Derivation Logic (3 steps)
#   - Implement logic to derive ALLOWED/FORBIDDEN from step file scope
#   - Make scenarios 002, 003, 004, 005 pass (content generation)
#
# PHASE 3: Post-Execution Validation (4 steps)
#   - Build ScopeValidator with git diff analysis
#   - Make scenarios 006, 007, 008 pass (validation logic)
#
# PHASE 4: Audit Integration (5 steps)
#   - Add SCOPE_VIOLATION audit event type and logging
#   - Make scenarios 009, 010, 011, 014 pass (audit trail + validation)
#
# Each step maps to ONE acceptance test scenario, ensuring 1:1 traceability.
# Total estimated effort: 28-32 hours across 4 phases.

# ============================================================================
# PHASE 1: Template Foundation (Build BOUNDARY_RULES rendering)
# ============================================================================

phases:
  - phase_id: "01"
    name: "Template Foundation - BOUNDARY_RULES Section Rendering"
    objective: >
      Create infrastructure to render BOUNDARY_RULES section in prompts,
      replacing placeholder comment with structured section header.
    estimated_hours: 6
    dependencies: []
    outcomes:
      - "BOUNDARY_RULES section header appears in all execute/develop prompts"
      - "Section structure includes ALLOWED, FORBIDDEN, and return control instruction"
      - "Scenarios 001, 012, 013 pass"

    steps:
      - step_id: "01-01"
        name: "Create BoundaryRulesTemplate class with section header rendering"
        description: >
          Implement BoundaryRulesTemplate class in src/des/templates/boundary_rules_template.py
          that renders the BOUNDARY_RULES section header and basic structure.
          Replace placeholder comment in orchestrator.py render_full_prompt() method
          where '# TODO: Add BOUNDARY_RULES section' comment appears.
        acceptance_criteria:
          - "BOUNDARY_RULES section header present in rendered prompts"
          - "Section includes ALLOWED and FORBIDDEN subsections"
          - "Template integrates with orchestrator.render_full_prompt()"
        suggested_agent: software-crafter
        dependencies: []
        estimated_hours: 2
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 48
        acceptance_test_scenario: test_scenario_001_step_execution_prompt_includes_boundary_rules_section
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          Update orchestrator.py render_full_prompt() method to call
          BoundaryRulesTemplate.render() instead of returning placeholder comment.
          Template should return multi-line string with "## BOUNDARY_RULES" header.

      - step_id: "01-02"
        name: "Implement complete BOUNDARY_RULES structure with all subsections"
        description: >
          Extend BoundaryRulesTemplate to include all required subsections:
          ALLOWED (file patterns), FORBIDDEN (prohibited actions), and
          return control instruction. Ensure structure is complete.
        acceptance_criteria:
          - "ALLOWED subsection present with file pattern placeholders"
          - "FORBIDDEN subsection present with prohibition placeholders"
          - "Return control instruction included"
          - "All subsections properly formatted as markdown"
        suggested_agent: software-crafter
        dependencies: ["01-01"]
        estimated_hours: 2
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 679
        acceptance_test_scenario: test_scenario_012_boundary_rules_has_complete_structure
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          Template should render three subsections:
          - "### ALLOWED" with bullet list of file patterns
          - "### FORBIDDEN" with bullet list of prohibited actions
          - "### RETURN CONTROL" with instruction to return after completion

      - step_id: "01-03"
        name: "Add BOUNDARY_RULES to /nw:develop command prompts"
        description: >
          Ensure BoundaryRulesTemplate.render() is invoked for both
          /nw:execute AND /nw:develop commands. Verify both command types
          receive identical BOUNDARY_RULES section.
        acceptance_criteria:
          - "/nw:develop command prompts include BOUNDARY_RULES section"
          - "Section structure identical to /nw:execute prompts"
          - "Both commands share same template rendering logic"
        suggested_agent: software-crafter
        dependencies: ["01-02"]
        estimated_hours: 2
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 727
        acceptance_test_scenario: test_scenario_013_develop_command_also_includes_boundary_rules
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          Verify orchestrator.render_full_prompt() handles both command types.
          May need to check command routing in orchestrator to ensure both
          execute and develop paths call BoundaryRulesTemplate.render().

# ============================================================================
# PHASE 2: Scope Derivation Logic (Generate ALLOWED/FORBIDDEN from step file)
# ============================================================================

  - phase_id: "02"
    name: "Scope Derivation Logic - ALLOWED/FORBIDDEN Content Generation"
    objective: >
      Implement business logic to derive ALLOWED file patterns and FORBIDDEN
      actions from step file scope definition. Make boundary rules specific
      to each step's target files. Integrate generator with orchestrator.
    estimated_hours: 9
    dependencies: ["01"]
    outcomes:
      - "ALLOWED patterns derived from step file scope.target_files and scope.allowed_patterns"
      - "FORBIDDEN actions explicitly enumerate other steps and unrelated files"
      - "BoundaryRulesGenerator integrated with orchestrator.render_full_prompt()"
      - "Graceful error handling for missing scope field"
      - "Scenarios 002, 003, 004, 005 pass"

    steps:
      - step_id: "02-01"
        name: "Create BoundaryRulesGenerator with orchestrator integration and error handling"
        description: >
          Implement BoundaryRulesGenerator class in src/des/application/boundary_rules_generator.py
          that reads step file scope field and extracts allowed file patterns.
          Handle scope.target_files, scope.test_files, and scope.allowed_patterns.

          CRITICAL: Integrate with orchestrator.render_full_prompt() by updating
          that method to instantiate BoundaryRulesGenerator, pass step file scope,
          and include generated ALLOWED/FORBIDDEN content in BoundaryRulesTemplate.render() call.

          ERROR HANDLING: Gracefully handle missing scope field - default to generic
          patterns with WARNING log.
        acceptance_criteria:
          - "ALLOWED section lists step file as implicitly allowed"
          - "Target files from scope.target_files appear in ALLOWED patterns"
          - "Test files from scope.test_files appear in ALLOWED patterns"
          - "Custom patterns from scope.allowed_patterns included"
          - "Orchestrator calls generator during render_full_prompt()"
          - "Missing scope field defaults to generic patterns: ['steps/**/*.json', 'src/**/*', 'tests/**/*']"
          - "WARNING logged when scope field missing or incomplete"
        suggested_agent: software-crafter
        dependencies: ["01-03"]
        estimated_hours: 4
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 104
        acceptance_test_scenario: test_scenario_002_boundary_rules_enumerate_allowed_actions
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          Generator should read step file JSON, extract scope object, and
          combine target_files, test_files, and allowed_patterns into single
          ALLOWED list.

          ORCHESTRATOR INTEGRATION:
          In orchestrator.py render_full_prompt():
            1. Load step file JSON
            2. generator = BoundaryRulesGenerator()
            3. allowed, forbidden = generator.generate_rules(step_file_scope)
            4. boundary_rules_section = BoundaryRulesTemplate.render(allowed, forbidden)
            5. Include boundary_rules_section in full prompt

          ERROR HANDLING:
            try:
              scope = step_data.get("scope", {})
              if not scope or not scope.get("target_files"):
                logger.warning("Step file missing scope field, using generic patterns")
                scope = default_generic_scope()
            except Exception as e:
              logger.warning(f"Error reading scope: {e}, using generic patterns")
              scope = default_generic_scope()

      - step_id: "02-02"
        name: "Implement ALLOWED pattern matching to step file target_files"
        description: >
          Ensure BoundaryRulesGenerator correctly maps step file target_files
          to glob patterns in ALLOWED section. Verify patterns match actual
          file paths that will be modified during step execution.

          NOTE: Can run in parallel with step 02-03 after 02-01 completes.
        acceptance_criteria:
          - "ALLOWED patterns accurately represent step target files"
          - "Patterns support glob syntax (**, *, exact paths)"
          - "UserRepository example: target_files maps to **/UserRepository* pattern"
        suggested_agent: software-crafter
        dependencies: ["02-01"]
        estimated_hours: 2
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 168
        acceptance_test_scenario: test_scenario_003_allowed_patterns_match_step_target_files
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          May need to convert exact paths to glob patterns for flexibility.
          Example: "src/repositories/UserRepository.py" -> "**/UserRepository*"
          to allow matching both implementation and test files.

      - step_id: "02-03"
        name: "Generate FORBIDDEN actions list (other steps, unrelated files)"
        description: >
          Extend BoundaryRulesGenerator to create FORBIDDEN section listing
          prohibited actions: other step files, unrelated source files,
          configuration files, and production deployment changes.

          NOTE: Can run in parallel with step 02-02 after 02-01 completes.
        acceptance_criteria:
          - "FORBIDDEN section explicitly mentions 'other step files'"
          - "Unrelated files and files outside scope marked as forbidden"
          - "Generic prohibitions cover unexpected modification types"
        suggested_agent: software-crafter
        dependencies: ["02-01"]
        estimated_hours: 2
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 242
        acceptance_test_scenario: test_scenario_004_boundary_rules_enumerate_forbidden_actions
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          FORBIDDEN should be generic enough to cover broad categories:
          - "Other step files (steps/*/*.json except this step)"
          - "Files not matching ALLOWED patterns above"
          - "Configuration files unless explicitly in scope"
          - "Production deployment files"

      - step_id: "02-04"
        name: "Add explicit FORBIDDEN prohibition against continuing to next step"
        description: >
          Ensure FORBIDDEN section includes specific instruction prohibiting
          agents from continuing to next step after completion. Agent must
          return control to Marcus for explicit next-step initiation.
        acceptance_criteria:
          - "FORBIDDEN includes 'Continue to next step after completion'"
          - "Instruction emphasizes 'RETURN CONTROL IMMEDIATELY' after step done"
          - "Agent understands to halt and await Marcus's next command"
        suggested_agent: software-crafter
        dependencies: ["02-03"]
        estimated_hours: 1
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 297
        acceptance_test_scenario: test_scenario_005_forbidden_includes_continuation_to_next_step
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          Add to FORBIDDEN list:
          - "Continue to next step without explicit instruction from Marcus"
          - "Proceed to subsequent steps autonomously"
          Include in return control subsection:
          - "RETURN CONTROL IMMEDIATELY after step completion"

# ============================================================================
# PHASE 3: Post-Execution Validation (Git diff analysis and scope checking)
# ============================================================================

  - phase_id: "03"
    name: "Post-Execution Validation - ScopeValidator with Git Diff Analysis"
    objective: >
      Implement ScopeValidator that compares git diff output against step file
      allowed patterns. Detect out-of-scope modifications after agent execution.
      Integrate with SubagentStopHook for automatic validation. Include robust
      error handling for git command failures.
    estimated_hours: 9
    dependencies: ["02"]
    outcomes:
      - "Git diff analysis detects files modified during step execution"
      - "ScopeValidator matches modified files against allowed patterns"
      - "Out-of-scope modifications flagged as violations"
      - "Git command failures handled gracefully with WARNING logs"
      - "Scenarios 006, 007, 008 pass"

    steps:
      - step_id: "03-01"
        name: "Create ScopeValidator class with git diff integration and error handling"
        description: >
          Implement ScopeValidator in src/des/validation/scope_validator.py
          that runs 'git diff --name-only' to get modified files and compares
          against allowed patterns from step file scope.

          ERROR HANDLING: Wrap git diff in try/except. On failure, log ERROR
          and return ValidationResult with has_violations=False,
          validation_skipped=True, reason='Git command unavailable in environment'.
          Include subprocess timeout (5 seconds) to prevent hanging.
        acceptance_criteria:
          - "ScopeValidator executes git diff command successfully"
          - "Modified file list extracted from git output"
          - "Pattern matching compares files against allowed_patterns"
          - "Out-of-scope files identified and returned"
          - "Git command wrapped in try/except with subprocess.CalledProcessError handling"
          - "Subprocess timeout set to 5 seconds"
          - "On git failure: ValidationResult has validation_skipped=True"
          - "On git failure: ERROR logged to audit trail with reason"
        suggested_agent: software-crafter
        dependencies: ["02-04"]
        estimated_hours: 4
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 357
        acceptance_test_scenario: test_scenario_006_scope_validation_detects_out_of_scope_modification
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          Git integration:
            try:
              result = subprocess.run(
                ['git', 'diff', '--name-only', 'HEAD'],
                capture_output=True,
                timeout=5,
                check=True,
                text=True
              )
              modified_files = result.stdout.strip().split('\n')
            except subprocess.TimeoutExpired:
              logger.error("Git diff timed out after 5 seconds")
              return ValidationResult(has_violations=False, validation_skipped=True,
                                      reason="Git command timeout")
            except subprocess.CalledProcessError as e:
              logger.error(f"Git diff failed: {e}")
              return ValidationResult(has_violations=False, validation_skipped=True,
                                      reason="Git command unavailable in environment")
            except FileNotFoundError:
              logger.error("Git executable not found")
              return ValidationResult(has_violations=False, validation_skipped=True,
                                      reason="Git not installed")

          Pattern matching:
            Use fnmatch or pathlib for glob pattern matching.
            Return ValidationResult with has_violations, out_of_scope_files,
            and violation_message fields.

      - step_id: "03-02"
        name: "Implement pattern matching to pass validation for in-scope files"
        description: >
          Ensure ScopeValidator correctly validates files matching allowed
          patterns. In-scope modifications should pass validation without
          violations. Test with UserRepository example.
        acceptance_criteria:
          - "Files matching allowed patterns pass validation"
          - "ValidationResult.has_violations == False for in-scope files"
          - "Validation status set to PASSED when all files in scope"
        suggested_agent: software-crafter
        dependencies: ["03-01"]
        estimated_hours: 2
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 405
        acceptance_test_scenario: test_scenario_007_in_scope_modifications_pass_validation
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          For each modified file, check if it matches ANY pattern in
          allowed_patterns list. Use fnmatch.fnmatch(file, pattern) or
          pathlib.Path.match() for glob pattern matching. All files must
          match at least one pattern to pass.

      - step_id: "03-03"
        name: "Add implicit allowlist for step file itself"
        description: >
          Ensure step file (e.g., steps/01-01.json) is always allowed,
          even if not explicitly listed in scope.allowed_patterns. Agents
          must be able to update step file with phase outcomes and state.
        acceptance_criteria:
          - "Step file modification always passes validation"
          - "Step file implicitly added to allowed patterns"
          - "Validation logic checks if modified file is the step file path"
        suggested_agent: software-crafter
        dependencies: ["03-02"]
        estimated_hours: 1
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 453
        acceptance_test_scenario: test_scenario_008_step_file_modification_always_allowed
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          Before pattern matching, check if modified file matches step file
          path. If yes, automatically allow (skip pattern matching for that file).
          Step file path passed to ScopeValidator.validate_scope() as parameter.

      - step_id: "03-04"
        name: "Integrate ScopeValidator with SubagentStopHook with error handling"
        description: >
          Add scope validation call to SubagentStopHook in orchestrator.py.
          Hook should run ScopeValidator.validate_scope() after agent execution
          completes, before returning control to user.

          ERROR HANDLING: Handle git diff failure in SubagentStopHook by logging
          warning and continuing (don't block agent completion). If validation_skipped,
          log WARNING with reason and allow step to complete normally.
        acceptance_criteria:
          - "SubagentStopHook invokes ScopeValidator post-execution"
          - "Validation runs automatically without user interaction"
          - "Validation results available for audit logging (next phase)"
          - "Git diff failure logged as WARNING, doesn't block step completion"
          - "Validation_skipped=True allows step to complete with WARNING log"
        suggested_agent: software-crafter
        dependencies: ["03-03"]
        estimated_hours: 2
        test_file: null  # Infrastructure step - no direct test
        scenario_line: null  # Infrastructure step - no direct test
        acceptance_test_scenario: null  # No direct test - infrastructure for Phase 4
        quality_gates:
          acceptance_test_must_fail_first: false  # Infrastructure step
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: false  # Infrastructure step
          refactor_level: 4
        implementation_notes: >
          SubagentStopHook exists in orchestrator.py. Extend it to:
          1. Load step file to get allowed patterns
          2. Run git diff to get modified files (with error handling from 03-01)
          3. Call ScopeValidator.validate_scope()
          4. Store validation result for audit logging (next phase)
          5. If validation_skipped, log WARNING but continue normally

          Error handling in hook:
            validation_result = scope_validator.validate_scope(...)
            if validation_result.validation_skipped:
              logger.warning(f"Scope validation skipped: {validation_result.reason}")
              # Continue without blocking - warnings logged to audit in Phase 4
            elif validation_result.has_violations:
              # Log violations to audit (Phase 4 implementation)
              pass

# ============================================================================
# PHASE 4: Audit Integration (SCOPE_VIOLATION logging and pre-invocation validation)
# ============================================================================

  - phase_id: "04"
    name: "Audit Integration - SCOPE_VIOLATION Event Logging and Validation"
    objective: >
      Add SCOPE_VIOLATION event type to audit logger and integrate with
      ScopeValidator. Log warnings to audit trail when scope violations
      detected. Verify pre-invocation validation blocks prompts missing
      BOUNDARY_RULES section. Provide Priya with PR review audit trail.
    estimated_hours: 7
    dependencies: ["03"]
    outcomes:
      - "SCOPE_VIOLATION event type added to AuditLogger"
      - "Violations logged with file path, step context, severity WARNING"
      - "Multiple violations generate multiple audit entries"
      - "Clean executions produce no violation logs"
      - "Pre-invocation validation blocks missing BOUNDARY_RULES"
      - "Scenarios 009, 010, 011, 014 pass"

    steps:
      - step_id: "04-01"
        name: "Add SCOPE_VIOLATION event type to AuditLogger"
        description: >
          Extend AuditLogger in src/des/adapters/driven/logging/audit_logger.py
          to support SCOPE_VIOLATION event type. Define event schema with
          required fields: step_file, out_of_scope_file, allowed_patterns,
          severity (WARNING), timestamp.
        acceptance_criteria:
          - "SCOPE_VIOLATION added to event_type enum or constants"
          - "Event schema includes step_file, out_of_scope_file, allowed_patterns"
          - "Severity level set to WARNING (not ERROR)"
          - "Timestamp automatically added to event"
        suggested_agent: software-crafter
        dependencies: ["03-04"]
        estimated_hours: 2
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 515
        acceptance_test_scenario: test_scenario_009_scope_violation_logged_to_audit_trail
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          AuditLogger likely has event type constants or enum. Add:
          SCOPE_VIOLATION = "SCOPE_VIOLATION"

          Event structure:
          {
            "event_type": "SCOPE_VIOLATION",
            "severity": "WARNING",
            "step_file": "steps/01-01.json",
            "out_of_scope_file": "src/services/OrderService.py",
            "allowed_patterns": ["**/UserRepository*"],
            "timestamp": "2026-01-29T14:30:00Z"
          }

      - step_id: "04-02"
        name: "Integrate ScopeValidator violations with AuditLogger in SubagentStopHook"
        description: >
          Update SubagentStopHook to log SCOPE_VIOLATION events when
          ScopeValidator detects out-of-scope modifications. One audit entry
          per violation. Include file path, step context, and allowed patterns.
        acceptance_criteria:
          - "SubagentStopHook calls AuditLogger.log() for each violation"
          - "Audit entry includes out-of-scope file path"
          - "Audit entry includes step file path for context"
          - "Allowed patterns included in audit data for debugging"
        suggested_agent: software-crafter
        dependencies: ["04-01"]
        estimated_hours: 2
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 515
        acceptance_test_scenario: test_scenario_009_scope_violation_logged_to_audit_trail
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          After ScopeValidator.validate_scope() returns result:

          if result.has_violations:
              for out_of_scope_file in result.out_of_scope_files:
                  audit_logger.log(
                      event_type="SCOPE_VIOLATION",
                      severity="WARNING",
                      step_file=step_file_path,
                      out_of_scope_file=out_of_scope_file,
                      allowed_patterns=allowed_patterns
                  )

      - step_id: "04-03"
        name: "Ensure multiple scope violations generate separate audit entries"
        description: >
          Verify that when agent modifies multiple out-of-scope files,
          each violation generates its own SCOPE_VIOLATION audit entry.
          Test with OrderService, PaymentService, and database.yml scenario.

          NOTE: Can run in parallel with step 04-04 after 04-02 completes.
        acceptance_criteria:
          - "Each out-of-scope file gets separate audit log entry"
          - "Multiple violations in single execution all logged"
          - "No violations grouped or summarized (one entry per file)"
        suggested_agent: software-crafter
        dependencies: ["04-02"]
        estimated_hours: 1
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 572
        acceptance_test_scenario: test_scenario_010_multiple_scope_violations_all_logged
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          This should already work from step 04-02 implementation (loop over
          out_of_scope_files). This step is validation/testing to ensure
          loop correctly creates one entry per violation. May need to verify
          AuditLogger doesn't deduplicate or batch events.

      - step_id: "04-04"
        name: "Verify clean executions (no violations) produce no warning logs"
        description: >
          Ensure that when agent only modifies in-scope files, NO
          SCOPE_VIOLATION entries appear in audit log. Clean executions
          should not clutter audit trail with false warnings.

          NOTE: Can run in parallel with step 04-03 after 04-02 completes.
        acceptance_criteria:
          - "In-scope-only executions generate zero SCOPE_VIOLATION events"
          - "Audit log remains clean when validation passes"
          - "Only actual violations logged (no false positives)"
        suggested_agent: software-crafter
        dependencies: ["04-02"]
        estimated_hours: 1
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 630
        acceptance_test_scenario: test_scenario_011_no_violations_no_warning_logs
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          This is a validation step. Ensure SubagentStopHook has conditional:

          if result.has_violations:
              # log violations
          else:
              # do nothing (no audit entries for clean execution)

          Test that else branch is truly silent (no INFO or DEBUG logs that
          might confuse users during PR review).

      - step_id: "04-05"
        name: "Verify pre-invocation validation blocks missing BOUNDARY_RULES"
        description: >
          Ensure PromptValidator correctly validates BOUNDARY_RULES section
          presence during pre-invocation validation. Missing BOUNDARY_RULES
          should BLOCK Task invocation with specific error message.

          This validates that the existing validation infrastructure (from US-002)
          correctly enforces BOUNDARY_RULES as a mandatory section.
        acceptance_criteria:
          - "PromptValidator.validate() returns is_valid=False when BOUNDARY_RULES missing"
          - "Error message identifies 'BOUNDARY_RULES' as the missing section"
          - "Error uses 'MISSING' terminology (not 'incomplete' or 'invalid')"
          - "Task invocation blocked when validation fails"
        suggested_agent: software-crafter
        dependencies: ["04-01"]  # Can start after audit logger extended
        estimated_hours: 1
        test_file: "tests/des/acceptance/test_us007_boundary_rules.py"
        scenario_line: 774
        acceptance_test_scenario: test_scenario_014_missing_boundary_rules_blocks_invocation
        quality_gates:
          acceptance_test_must_fail_first: true
          unit_tests_must_fail_first: true
          no_mocks_inside_hexagon: true
          business_language_required: true
          refactor_level: 4
        implementation_notes: >
          Test scenario 014 (line 774) validates PRE-INVOCATION blocking, not
          post-execution validation. This step ensures the existing MandatorySectionChecker
          (validator.py line 66) correctly validates BOUNDARY_RULES presence.

          The test creates an incomplete prompt missing BOUNDARY_RULES and verifies:
          1. PromptValidator.validate() returns is_valid=False
          2. Error message contains "BOUNDARY_RULES"
          3. Error message contains "MISSING"

          This is validation/testing of existing infrastructure, not new implementation.
          The validator should already check for BOUNDARY_RULES in MANDATORY_SECTIONS list.

# ============================================================================
# ROADMAP SUMMARY
# ============================================================================

summary:
  total_phases: 4
  total_steps: 15
  total_estimated_hours: 31

  phase_breakdown:
    phase_01_template_foundation: 6 hours
    phase_02_scope_derivation: 9 hours
    phase_03_post_execution_validation: 9 hours
    phase_04_audit_integration: 7 hours

  acceptance_test_coverage:
    total_scenarios: 14
    scenarios_mapped: 14
    mapping_completeness: 100%

  step_to_scenario_mapping:
    "01-01": test_scenario_001_step_execution_prompt_includes_boundary_rules_section
    "01-02": test_scenario_012_boundary_rules_has_complete_structure
    "01-03": test_scenario_013_develop_command_also_includes_boundary_rules
    "02-01": test_scenario_002_boundary_rules_enumerate_allowed_actions
    "02-02": test_scenario_003_allowed_patterns_match_step_target_files
    "02-03": test_scenario_004_boundary_rules_enumerate_forbidden_actions
    "02-04": test_scenario_005_forbidden_includes_continuation_to_next_step
    "03-01": test_scenario_006_scope_validation_detects_out_of_scope_modification
    "03-02": test_scenario_007_in_scope_modifications_pass_validation
    "03-03": test_scenario_008_step_file_modification_always_allowed
    "03-04": null  # Infrastructure step - no direct test scenario
    "04-01": test_scenario_009_scope_violation_logged_to_audit_trail
    "04-02": test_scenario_009_scope_violation_logged_to_audit_trail (integration)
    "04-03": test_scenario_010_multiple_scope_violations_all_logged
    "04-04": test_scenario_011_no_violations_no_warning_logs
    "04-05": test_scenario_014_missing_boundary_rules_blocks_invocation

  critical_path:
    - "Phase 1 must complete before Phase 2 (template foundation required)"
    - "Phase 2 must complete before Phase 3 (scope patterns needed for validation)"
    - "Phase 3 must complete before Phase 4 (validation results needed for logging)"

  parallel_execution_opportunities:
    - "Steps 02-02 (ALLOWED pattern matching) and 02-03 (FORBIDDEN generation) can execute in parallel after 02-01 completes"
    - "Steps 04-03 (multiple violations) and 04-04 (no violations) can execute in parallel after 04-02 completes"
    - "Step 04-05 (pre-invocation validation) can start after 04-01 completes, independent of 04-02/04-03/04-04"

  risk_mitigation:
    - risk: "Step files may lack scope field in production"
      mitigation: "Phase 2 Step 02-01 includes graceful degradation with WARNING log (generic patterns)"
      implemented_in: "02-01"

    - risk: "Git diff may fail in non-git environments"
      mitigation: "Phase 3 Step 03-01 wraps git commands in try/except with subprocess timeout, logs ERROR, returns validation_skipped=True"
      implemented_in: "03-01, 03-04"

    - risk: "Pattern matching complexity for glob syntax"
      mitigation: "Phase 3 Step 03-02 uses fnmatch or pathlib (Python stdlib, reliable)"
      implemented_in: "03-02"

    - risk: "Git command hangs or times out"
      mitigation: "Subprocess timeout set to 5 seconds in step 03-01"
      implemented_in: "03-01"

# ============================================================================
# NEXT STEPS
# ============================================================================

next_steps:
  - action: "Review roadmap with stakeholders"
    owner: "solution-architect (Morgan)"

  - action: "Approve roadmap for split phase"
    owner: "solution-architect-reviewer (Atlas)"

  - action: "Generate atomic task files via /nw:split"
    owner: "orchestrator"
    command: "/nw:split @software-crafter des-us007-boundary-rules"

  - action: "Execute task files sequentially via /nw:execute"
    owner: "software-crafter (Sam)"
    sequence: "steps/01-01.json through steps/04-05.json"

# ============================================================================
# REVISION NOTES
# ============================================================================

revision_history:
  - revision: 2
    date: '2026-01-29T00:00:00Z'
    changes:
      - "FIXED HIGH: Corrected step 03-04 test scenario mapping - now infrastructure step (no direct test)"
      - "ADDED: Step 04-05 to validate pre-invocation blocking (test_scenario_014) - correctly maps to PRE-INVOCATION validation"
      - "FIXED HIGH: Added orchestrator integration specification in step 02-01 (BoundaryRulesGenerator called from render_full_prompt())"
      - "FIXED HIGH: Added error handling specifications for missing scope field in step 02-01 (graceful degradation with WARNING)"
      - "FIXED HIGH: Added git diff error handling in step 03-01 (try/except, timeout, validation_skipped)"
      - "FIXED HIGH: Added git failure handling in SubagentStopHook in step 03-04 (WARNING log, don't block)"
      - "FIXED MEDIUM: Documented parallel execution opportunities (02-02/02-03, 04-03/04-04, 04-05 independent)"
      - "IMPROVED: Replaced line number references with structural references (render_full_prompt method)"
      - "UPDATED: Total steps 14→15 (added 04-05), total hours 28→31"

# ============================================================================
# REVIEW HISTORY
# ============================================================================

reviews:
  - reviewer: software-crafter-reviewer
    attempt: 1
    date: '2026-01-29T00:00:00Z'
    overall_assessment: NEEDS_REVISION
    ready_for_split: false
    issues_identified:
      - issue_id: 1
        severity: HIGH
        category: test_scenario_mapping
        finding: "Step 03-04 incorrectly mapped to test_scenario_014"
        evidence: "Line 380: acceptance_test_scenario: test_scenario_014. Test scenario 014 validates PRE-INVOCATION blocking, not SubagentStopHook integration"
        impact: "1:1 step-to-test traceability broken, confusion about what 03-04 validates"
        recommendation: "Change 03-04 to acceptance_test_scenario: null (infrastructure step). Add new step 04-05 that correctly maps to test_scenario_014 for pre-invocation validation"

      - issue_id: 2
        severity: HIGH
        category: orchestrator_integration
        finding: "BoundaryRulesGenerator never integrated with orchestrator.render_full_prompt()"
        evidence: "Step 02-01 creates generator class but doesn't specify WHERE it's called. Orchestrator integration missing from implementation notes"
        impact: "Generator will exist but never be invoked - boundary rules won't be generated"
        recommendation: "Add explicit orchestrator integration specification in step 02-01: Update render_full_prompt() to instantiate generator, call generate_rules(), pass results to BoundaryRulesTemplate.render()"

      - issue_id: 3
        severity: HIGH
        category: error_handling
        finding: "Missing error handling specifications for production edge cases"
        evidence: "Step 02-01: No handling for missing scope field. Step 03-01: No handling for git diff failure. Step 03-04: No handling for validation_skipped scenario"
        impact: "Production failures when step files lack scope or git unavailable in environment"
        recommendation: "Add ERROR HANDLING sections to steps 02-01 (scope missing), 03-01 (git failure), 03-04 (SubagentStopHook git failure handling)"

    strengths:
      - "Comprehensive 4-phase structure with clear progression"
      - "100% scenario coverage achieved (14/14 scenarios mapped)"
      - "Parallel execution opportunities identified for efficiency"
      - "Risk mitigation section demonstrates production awareness"

  - reviewer: software-crafter-reviewer
    attempt: 2
    date: '2026-01-29T01:00:00Z'
    overall_assessment: APPROVED
    ready_for_split: true

    verification_of_fixes:
      issue_1_test_scenario_mapping:
        status: RESOLVED
        verification: "Step 03-04 now correctly marked as 'null' (infrastructure step). New step 04-05 added with correct test_scenario_014 mapping for pre-invocation validation"
        evidence: "Line 380: acceptance_test_scenario: null. Line 544: acceptance_test_scenario: test_scenario_014_missing_boundary_rules_blocks_invocation"
        quality: "Excellent - 1:1 traceability restored, infrastructure step clearly identified"

      issue_2_orchestrator_integration:
        status: RESOLVED
        verification: "Step 02-01 now includes comprehensive orchestrator integration specification"
        evidence: |
          Lines 165-172: ORCHESTRATOR INTEGRATION section with 5-step integration procedure:
          1. Load step file JSON
          2. generator = BoundaryRulesGenerator()
          3. allowed, forbidden = generator.generate_rules(step_file_scope)
          4. boundary_rules_section = BoundaryRulesTemplate.render(allowed, forbidden)
          5. Include boundary_rules_section in full prompt
        quality: "Excellent - integration explicitly specified with implementable steps"

      issue_3_error_handling:
        status: RESOLVED
        verification: "All three error handling gaps addressed with comprehensive specifications"
        evidence: |
          Step 02-01 (lines 152-181): Missing scope field handling with generic fallback
          Step 03-01 (lines 295-316): Git diff wrapped in try/except with timeout, three error cases covered
          Step 03-04 (lines 389-396): validation_skipped scenario handled with WARNING log
        quality: "Excellent - production-ready error handling with graceful degradation"

    new_issues_identified: []

    quality_improvements:
      - improvement: "Parallel execution opportunities documented"
        value: "Steps 02-02/02-03, 04-03/04-04, and 04-05 can run concurrently, reducing total implementation time"

      - improvement: "Subprocess timeout added to git commands"
        value: "5-second timeout prevents hanging in edge cases, improves system reliability"

      - improvement: "Risk mitigation section expanded"
        value: "All identified risks now have concrete mitigation strategies with implementing step references"

    technical_feasibility: HIGH
    implementation_clarity: HIGH
    test_coverage_adequacy: COMPLETE

    final_validation:
      step_to_scenario_mapping: "✅ 100% correct (14 scenarios mapped, 1 infrastructure step identified)"
      orchestrator_integration: "✅ Explicitly specified in step 02-01"
      error_handling: "✅ Comprehensive coverage for production edge cases"
      phase_sequencing: "✅ Dependencies correctly structured, critical path identified"
      total_effort_estimate: "✅ 31 hours realistic for scope (15 steps, 4 phases)"

    approval_rationale: |
      All 3 HIGH severity issues from first review have been completely resolved:

      1. Test scenario mapping corrected - 04-05 now handles test_scenario_014
      2. Orchestrator integration explicitly specified with 5-step procedure
      3. Error handling comprehensive for all production edge cases

      Roadmap demonstrates production-ready thinking with:
      - Graceful degradation for missing data
      - Timeout protection for subprocess calls
      - Clear WARNING vs ERROR distinction
      - Infrastructure step correctly identified as having no direct test

      No new issues introduced. Quality improvements enhance implementation clarity.
      Ready for split phase and sequential execution.

    recommendations_for_execution:
      - "Follow phase sequence strictly - each phase builds on previous foundation"
      - "Test error handling paths explicitly during implementation (missing scope, git failure)"
      - "Verify orchestrator integration in step 02-01 before proceeding to Phase 3"
      - "Use parallel execution opportunities (02-02/02-03, 04-03/04-04) to reduce timeline"
